import{c as tt,g as zt}from"./index-F75dCemF.js";function Xt(v,r){for(var y=0;y<r.length;y++){const b=r[y];if(typeof b!="string"&&!Array.isArray(b)){for(const O in b)if(O!=="default"&&!(O in v)){const i=Object.getOwnPropertyDescriptor(b,O);i&&Object.defineProperty(v,O,i.get?i:{enumerable:!0,get:()=>b[O]})}}}return Object.freeze(Object.defineProperty(v,Symbol.toStringTag,{value:"Module"}))}var he={},pe,nt;function We(){return nt||(nt=1,pe=class Ht{constructor(r,y=new Map,b=0){this.prefix=r,this._existing=y,this.counter=b}clone(){const{prefix:r,_existing:y,counter:b}=this;return new Ht(r,new Map(y),b)}getId(r){const y=r&&this._existing.get(r);if(y)return y;const b=this.prefix+this.counter;return this.counter++,r&&this._existing.set(r,b),b}hasId(r){return this._existing.has(r)}getOldIds(){return[...this._existing.keys()]}}),pe}var ae={},ge={},rt;function Qt(){return rt||(rt=1,(function(v,r){if(v.setImmediate)return;var y=1,b={},O=!1,i=v.document,n;function t(J){typeof J!="function"&&(J=new Function(""+J));for(var l=new Array(arguments.length-1),e=0;e<l.length;e++)l[e]=arguments[e+1];var s={callback:J,args:l};return b[y]=s,n(y),y++}function c(J){delete b[J]}function w(J){var l=J.callback,e=J.args;switch(e.length){case 0:l();break;case 1:l(e[0]);break;case 2:l(e[0],e[1]);break;case 3:l(e[0],e[1],e[2]);break;default:l.apply(r,e);break}}function I(J){if(O)setTimeout(I,0,J);else{var l=b[J];if(l){O=!0;try{w(l)}finally{c(J),O=!1}}}}function R(){n=function(J){process.nextTick(function(){I(J)})}}function u(){if(v.postMessage&&!v.importScripts){var J=!0,l=v.onmessage;return v.onmessage=function(){J=!1},v.postMessage("","*"),v.onmessage=l,J}}function m(){var J="setImmediate$"+Math.random()+"$",l=function(e){e.source===v&&typeof e.data=="string"&&e.data.indexOf(J)===0&&I(+e.data.slice(J.length))};v.addEventListener?v.addEventListener("message",l,!1):v.attachEvent("onmessage",l),n=function(e){v.postMessage(J+e,"*")}}function E(){var J=new MessageChannel;J.port1.onmessage=function(l){var e=l.data;I(e)},n=function(l){J.port2.postMessage(l)}}function N(){var J=i.documentElement;n=function(l){var e=i.createElement("script");e.onreadystatechange=function(){I(l),e.onreadystatechange=null,J.removeChild(e),e=null},J.appendChild(e)}}function F(){n=function(J){setTimeout(I,0,J)}}var B=Object.getPrototypeOf&&Object.getPrototypeOf(v);B=B&&B.setTimeout?B:v,{}.toString.call(v.process)==="[object process]"?R():u()?m():v.MessageChannel?E():i&&"onreadystatechange"in i.createElement("script")?N():F(),B.setImmediate=t,B.clearImmediate=c})(typeof self>"u"?typeof tt>"u"?ge:tt:self)),ge}var it;function Pt(){if(it)return ae;it=1,Qt(),ae.setImmediate=setImmediate,ae.crypto=globalThis.crypto;const v=[];for(let r=0;r<=255;++r)v.push(r.toString(16).padStart(2,"0"));return ae.bufferToHex=function(y){let b="";const O=new Uint8Array(y);for(let i=0;i<O.length;++i)b+=v[O[i]];return b},ae}var ye,st;function Ut(){if(st)return ye;st=1;const{bufferToHex:v,crypto:r}=Pt(),y=new Map([["sha256","SHA-256"],["SHA256","SHA-256"],["SHA-256","SHA-256"],["sha384","SHA-384"],["SHA384","SHA-384"],["SHA-384","SHA-384"],["sha512","SHA-512"],["SHA512","SHA-512"],["SHA-512","SHA-512"]]);return ye=class{constructor(O){if(!(r&&r.subtle))throw new Error("crypto.subtle not found.");if(!y.has(O))throw new Error(`Unsupported algorithm "${O}".`);this.algorithm=y.get(O),this._content=""}update(O){this._content+=O}async digest(){const O=new TextEncoder().encode(this._content),i=await r.subtle.digest(this.algorithm,O);return v(i)}},ye}var me,at;function Bt(){return at||(at=1,me=class{constructor(r){this.current=r.sort(),this.done=!1,this.dir=new Map;for(let y=0;y<r.length;++y)this.dir.set(r[y],!0)}hasNext(){return!this.done}next(){const{current:r,dir:y}=this,b=r.slice();let O=null,i=0;const n=r.length;for(let t=0;t<n;++t){const c=r[t],w=y.get(c);(O===null||c>O)&&(w&&t>0&&c>r[t-1]||!w&&t<n-1&&c>r[t+1])&&(O=c,i=t)}if(O===null)this.done=!0;else{const t=y.get(O)?i-1:i+1;r[i]=r[t],r[t]=O;for(const c of r)c>O&&y.set(c,!y.get(c))}return b}}),me}var ve,ot;function Ke(){if(ot)return ve;ot=1;const r="http://www.w3.org/1999/02/22-rdf-syntax-ns#"+"langString",y="http://www.w3.org/2001/XMLSchema#string",b="NamedNode",O="BlankNode",i="Literal",n="DefaultGraph",t={};(()=>{const e="A-Za-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�"+"_",s=e+"0-9-·̀-ͯ‿-⁀",d="_:((?:["+e+"0-9])(?:(?:["+s+".])*(?:["+s+"]))?)",g='(?:<((?:[^\0- <>"{}|^`\\\\]|'+"\\\\u[0-9A-Fa-f]{4}"+"|"+"\\\\U[0-9A-Fa-f]{8}"+")*)>)",f=d,L='"([^"\\\\]*(?:\\\\.[^"\\\\]*)*)"',M="(?:\\^\\^"+g+")",h="(?:"+L+"(?:"+M+"|"+"(?:@([a-zA-Z]+(?:-[a-zA-Z0-9]+)*))"+")?)",q="[ \\t]+",a="[ \\t]*",j="(?:"+g+"|"+f+")"+q,A=g+q,k="(?:"+g+"|"+f+"|"+h+")"+a,p="(?:\\.|(?:(?:"+g+"|"+f+")"+a+"\\.))";t.eoln=/(?:\r\n)|(?:\n)|(?:\r)/g,t.empty=new RegExp("^"+a+"$"),t.quad=new RegExp("^"+a+j+A+k+p+a+"$")})(),ve=class Ce{static parse(e){const s=[],d={},T=e.split(t.eoln);let o=0;for(const g of T){if(o++,t.empty.test(g))continue;const f=g.match(t.quad);if(f===null)throw new Error("N-Quads parse error on line "+o+".");const L={subject:null,predicate:null,object:null,graph:null};if(f[1]!==void 0?L.subject={termType:b,value:J(f[1])}:L.subject={termType:O,value:f[2]},L.predicate={termType:b,value:J(f[3])},f[4]!==void 0?L.object={termType:b,value:J(f[4])}:f[5]!==void 0?L.object={termType:O,value:f[5]}:(L.object={termType:i,value:void 0,datatype:{termType:b}},f[7]!==void 0?L.object.datatype.value=J(f[7]):f[8]!==void 0?(L.object.datatype.value=r,L.object.language=f[8]):L.object.datatype.value=y,L.object.value=m(f[6])),f[9]!==void 0?L.graph={termType:b,value:J(f[9])}:f[10]!==void 0?L.graph={termType:O,value:f[10]}:L.graph={termType:n,value:""},!(L.graph.value in d))d[L.graph.value]=[L],s.push(L);else{let M=!0;const D=d[L.graph.value];for(const h of D)if(c(h,L)){M=!1;break}M&&(D.push(L),s.push(L))}}return s}static serialize(e){const s=[];for(const d of e)s.push(Ce.serializeQuad(d));return s.sort().join("")}static serializeQuadComponents(e,s,d,T){let o="";return e.termType===b?o+=`<${F(e.value)}>`:o+=`_:${e.value}`,s.termType===b?o+=` <${F(s.value)}> `:o+=` _:${s.value} `,d.termType===b?o+=`<${F(d.value)}>`:d.termType===O?o+=`_:${d.value}`:(o+=`"${R(d.value)}"`,d.datatype.value===r?d.language&&(o+=`@${d.language}`):d.datatype.value!==y&&(o+=`^^<${F(d.datatype.value)}>`)),T.termType===b?o+=` <${F(T.value)}>`:T.termType===O&&(o+=` _:${T.value}`),o+=` .
`,o}static serializeQuad(e){return Ce.serializeQuadComponents(e.subject,e.predicate,e.object,e.graph)}};function c(l,e){return!(l.subject.termType===e.subject.termType&&l.object.termType===e.object.termType)||!(l.subject.value===e.subject.value&&l.predicate.value===e.predicate.value&&l.object.value===e.object.value)?!1:l.object.termType!==i?!0:l.object.datatype.termType===e.object.datatype.termType&&l.object.language===e.object.language&&l.object.datatype.value===e.object.datatype.value}const w=/[\u0000-\u001F\u007F"\\]/g,I=[];for(let l=0;l<=127;++l)w.test(String.fromCharCode(l))&&(I[l]="\\u"+l.toString(16).toUpperCase().padStart(4,"0"),w.lastIndex=0);I["\b".codePointAt(0)]="\\b",I["	".codePointAt(0)]="\\t",I[`
`.codePointAt(0)]="\\n",I["\f".codePointAt(0)]="\\f",I["\r".codePointAt(0)]="\\r",I['"'.codePointAt(0)]='\\"',I["\\".codePointAt(0)]="\\\\";function R(l){return w.test(l)?l.replace(w,function(e){return I[e.codePointAt(0)]}):l}const u=/(?:\\([btnfr"'\\]))|(?:\\u([0-9A-Fa-f]{4}))|(?:\\U([0-9A-Fa-f]{8}))/g;function m(l){return u.test(l)?l.replace(u,function(e,s,d,T){if(s)switch(s){case"b":return"\b";case"t":return"	";case"n":return`
`;case"f":return"\f";case"r":return"\r";case'"':return'"';case"'":return"'";case"\\":return"\\"}if(d)return String.fromCharCode(parseInt(d,16));if(T)return String.fromCodePoint(parseInt(T,16))}):l}const E=/[\u0000-\u0020<>"{}|^`\\]/g,N=[];for(let l=0;l<=127;++l)E.test(String.fromCharCode(l))&&(N[l]="\\u"+l.toString(16).toUpperCase().padStart(4,"0"),E.lastIndex=0);function F(l){return E.test(l)?l.replace(E,function(e){return N[e.codePointAt(0)]}):l}const B=/(?:\\u([0-9A-Fa-f]{4}))|(?:\\U([0-9A-Fa-f]{8}))/g;function J(l){return B.test(l)?l.replace(B,function(e,s,d){if(s)return String.fromCharCode(parseInt(s,16));if(d)return String.fromCodePoint(parseInt(d,16))}):l}return ve}var be,lt;function Ct(){if(lt)return be;lt=1;const v=We(),r=Ut(),y=Bt(),b=Ke(),{setImmediate:O}=Pt();be=class{constructor({createMessageDigest:t=null,messageDigestAlgorithm:c="sha256",canonicalIdMap:w=new Map,maxWorkFactor:I=1,maxDeepIterations:R=-1,signal:u=null}={}){this.name="RDFC-1.0",this.blankNodeInfo=new Map,this.canonicalIssuer=new v("c14n",w),this.createMessageDigest=t||(()=>new r(c)),this.maxWorkFactor=I,this.maxDeepIterations=R,this.remainingDeepIterations=0,this.signal=u,this.quads=null}async main(t){this.quads=t;for(const E of t)this._addBlankNodeQuadInfo({quad:E,component:E.subject}),this._addBlankNodeQuadInfo({quad:E,component:E.object}),this._addBlankNodeQuadInfo({quad:E,component:E.graph});const c=new Map,w=[...this.blankNodeInfo.keys()];let I=0;for(const E of w)++I%100===0&&await this._yield(),await this._hashAndTrackBlankNode({id:E,hashToBlankNodes:c});const R=[...c.keys()].sort(),u=[];for(const E of R){const N=c.get(E);if(N.length>1){u.push(N);continue}const F=N[0];this.canonicalIssuer.getId(F)}if(this.maxDeepIterations<0)if(this.maxWorkFactor===0)this.maxDeepIterations=0;else if(this.maxWorkFactor===1/0)this.maxDeepIterations=1/0;else{const E=u.reduce((N,F)=>N+F.length,0);this.maxDeepIterations=E**this.maxWorkFactor}this.maxDeepIterations>Number.MAX_SAFE_INTEGER&&(this.maxDeepIterations=1/0),this.remainingDeepIterations=this.maxDeepIterations;for(const E of u){const N=[];for(const F of E){if(this.canonicalIssuer.hasId(F))continue;const B=new v("b");B.getId(F);const J=await this.hashNDegreeQuads(F,B);N.push(J)}N.sort(i);for(const F of N){const B=F.issuer.getOldIds();for(const J of B)this.canonicalIssuer.getId(J)}}const m=[];for(const E of this.quads){const N=b.serializeQuadComponents(this._componentWithCanonicalId(E.subject),E.predicate,this._componentWithCanonicalId(E.object),this._componentWithCanonicalId(E.graph));m.push(N)}return m.sort(),m.join("")}async hashFirstDegreeQuads(t){const c=[],w=this.blankNodeInfo.get(t),I=w.quads;for(const u of I)c.push(b.serializeQuadComponents(this.modifyFirstDegreeComponent(t,u.subject,"subject"),u.predicate,this.modifyFirstDegreeComponent(t,u.object,"object"),this.modifyFirstDegreeComponent(t,u.graph,"graph")));c.sort();const R=this.createMessageDigest();for(const u of c)R.update(u);return w.hash=await R.digest(),w.hash}async hashRelatedBlankNode(t,c,w,I){const R=this.createMessageDigest();R.update(I),I!=="g"&&R.update(this.getRelatedPredicate(c));let u;return this.canonicalIssuer.hasId(t)?u="_:"+this.canonicalIssuer.getId(t):w.hasId(t)?u="_:"+w.getId(t):u=this.blankNodeInfo.get(t).hash,R.update(u),R.digest()}async hashNDegreeQuads(t,c){if(this.remainingDeepIterations===0)throw new Error(`Maximum deep iterations exceeded (${this.maxDeepIterations}).`);this.remainingDeepIterations--;const w=this.createMessageDigest(),I=await this.createHashToRelated(t,c),R=[...I.keys()].sort();for(const u of R){w.update(u);let m="",E;const N=new y(I.get(u));let F=0;for(;N.hasNext();){const B=N.next();if(++F%3===0){if(this.signal&&this.signal.aborted)throw new Error(`Abort signal received: "${this.signal.reason}".`);await this._yield()}let J=c.clone(),l="";const e=[];let s=!1;for(const d of B)if(this.canonicalIssuer.hasId(d)?l+="_:"+this.canonicalIssuer.getId(d):(J.hasId(d)||e.push(d),l+="_:"+J.getId(d)),m.length!==0&&l>m){s=!0;break}if(!s){for(const d of e){const T=await this.hashNDegreeQuads(d,J);if(l+="_:"+J.getId(d),l+=`<${T.hash}>`,J=T.issuer,m.length!==0&&l>m){s=!0;break}}s||(m.length===0||l<m)&&(m=l,E=J)}}w.update(m),c=E}return{hash:await w.digest(),issuer:c}}modifyFirstDegreeComponent(t,c){return c.termType!=="BlankNode"?c:{termType:"BlankNode",value:c.value===t?"a":"z"}}getRelatedPredicate(t){return`<${t.predicate.value}>`}async createHashToRelated(t,c){const w=new Map,I=this.blankNodeInfo.get(t).quads;let R=0;for(const u of I)++R%100===0&&await this._yield(),await Promise.all([this._addRelatedBlankNodeHash({quad:u,component:u.subject,position:"s",id:t,issuer:c,hashToRelated:w}),this._addRelatedBlankNodeHash({quad:u,component:u.object,position:"o",id:t,issuer:c,hashToRelated:w}),this._addRelatedBlankNodeHash({quad:u,component:u.graph,position:"g",id:t,issuer:c,hashToRelated:w})]);return w}async _hashAndTrackBlankNode({id:t,hashToBlankNodes:c}){const w=await this.hashFirstDegreeQuads(t),I=c.get(w);I?I.push(t):c.set(w,[t])}_addBlankNodeQuadInfo({quad:t,component:c}){if(c.termType!=="BlankNode")return;const w=c.value,I=this.blankNodeInfo.get(w);I?I.quads.add(t):this.blankNodeInfo.set(w,{quads:new Set([t]),hash:null})}async _addRelatedBlankNodeHash({quad:t,component:c,position:w,id:I,issuer:R,hashToRelated:u}){if(!(c.termType==="BlankNode"&&c.value!==I))return;const m=c.value,E=await this.hashRelatedBlankNode(m,t,R,w),N=u.get(E);N?N.push(m):u.set(E,[m])}_componentWithCanonicalId(t){return t.termType==="BlankNode"&&!t.value.startsWith(this.canonicalIssuer.prefix)?{termType:"BlankNode",value:this.canonicalIssuer.getId(t.value)}:t}async _yield(){return new Promise(t=>O(t))}};function i(n,t){return n.hash<t.hash?-1:n.hash>t.hash?1:0}return be}var we,ct;function Wt(){if(ct)return we;ct=1;const v=We(),r=Ut(),y=Bt(),b=Ke();we=class{constructor({createMessageDigest:n=null,messageDigestAlgorithm:t="sha256",canonicalIdMap:c=new Map,maxWorkFactor:w=1,maxDeepIterations:I=-1,timeout:R=0}={}){this.name="RDFC-1.0",this.blankNodeInfo=new Map,this.canonicalIssuer=new v("c14n",c),this.createMessageDigest=n||(()=>new r(t)),this.maxWorkFactor=w,this.maxDeepIterations=I,this.remainingDeepIterations=0,this.timeout=R,R>0&&(this.startTime=Date.now()),this.quads=null}main(n){this.quads=n;for(const u of n)this._addBlankNodeQuadInfo({quad:u,component:u.subject}),this._addBlankNodeQuadInfo({quad:u,component:u.object}),this._addBlankNodeQuadInfo({quad:u,component:u.graph});const t=new Map,c=[...this.blankNodeInfo.keys()];for(const u of c)this._hashAndTrackBlankNode({id:u,hashToBlankNodes:t});const w=[...t.keys()].sort(),I=[];for(const u of w){const m=t.get(u);if(m.length>1){I.push(m);continue}const E=m[0];this.canonicalIssuer.getId(E)}if(this.maxDeepIterations<0)if(this.maxWorkFactor===0)this.maxDeepIterations=0;else if(this.maxWorkFactor===1/0)this.maxDeepIterations=1/0;else{const u=I.reduce((m,E)=>m+E.length,0);this.maxDeepIterations=u**this.maxWorkFactor}this.maxDeepIterations>Number.MAX_SAFE_INTEGER&&(this.maxDeepIterations=1/0),this.remainingDeepIterations=this.maxDeepIterations;for(const u of I){const m=[];for(const E of u){if(this.canonicalIssuer.hasId(E))continue;const N=new v("b");N.getId(E);const F=this.hashNDegreeQuads(E,N);m.push(F)}m.sort(O);for(const E of m){const N=E.issuer.getOldIds();for(const F of N)this.canonicalIssuer.getId(F)}}const R=[];for(const u of this.quads){const m=b.serializeQuadComponents(this._componentWithCanonicalId(u.subject),u.predicate,this._componentWithCanonicalId(u.object),this._componentWithCanonicalId(u.graph));R.push(m)}return R.sort(),R.join("")}hashFirstDegreeQuads(n){const t=[],c=this.blankNodeInfo.get(n),w=c.quads;for(const R of w)t.push(b.serializeQuadComponents(this.modifyFirstDegreeComponent(n,R.subject,"subject"),R.predicate,this.modifyFirstDegreeComponent(n,R.object,"object"),this.modifyFirstDegreeComponent(n,R.graph,"graph")));t.sort();const I=this.createMessageDigest();for(const R of t)I.update(R);return c.hash=I.digest(),c.hash}hashRelatedBlankNode(n,t,c,w){const I=this.createMessageDigest();I.update(w),w!=="g"&&I.update(this.getRelatedPredicate(t));let R;return this.canonicalIssuer.hasId(n)?R="_:"+this.canonicalIssuer.getId(n):c.hasId(n)?R="_:"+c.getId(n):R=this.blankNodeInfo.get(n).hash,I.update(R),I.digest()}hashNDegreeQuads(n,t){if(this.remainingDeepIterations===0)throw new Error(`Maximum deep iterations exceeded (${this.maxDeepIterations}).`);this.remainingDeepIterations--;const c=this.createMessageDigest(),w=this.createHashToRelated(n,t),I=[...w.keys()].sort();for(const R of I){c.update(R);let u="",m;const E=new y(w.get(R));let N=0;for(;E.hasNext();){const F=E.next();if(++N%3===0&&this.timeout>0&&Date.now()-this.startTime>this.timeout)throw new Error("Canonize timeout.");let B=t.clone(),J="";const l=[];let e=!1;for(const s of F)if(this.canonicalIssuer.hasId(s)?J+="_:"+this.canonicalIssuer.getId(s):(B.hasId(s)||l.push(s),J+="_:"+B.getId(s)),u.length!==0&&J>u){e=!0;break}if(!e){for(const s of l){const d=this.hashNDegreeQuads(s,B);if(J+="_:"+B.getId(s),J+=`<${d.hash}>`,B=d.issuer,u.length!==0&&J>u){e=!0;break}}e||(u.length===0||J<u)&&(u=J,m=B)}}c.update(u),t=m}return{hash:c.digest(),issuer:t}}modifyFirstDegreeComponent(n,t){return t.termType!=="BlankNode"?t:{termType:"BlankNode",value:t.value===n?"a":"z"}}getRelatedPredicate(n){return`<${n.predicate.value}>`}createHashToRelated(n,t){const c=new Map,w=this.blankNodeInfo.get(n).quads;for(const I of w)this._addRelatedBlankNodeHash({quad:I,component:I.subject,position:"s",id:n,issuer:t,hashToRelated:c}),this._addRelatedBlankNodeHash({quad:I,component:I.object,position:"o",id:n,issuer:t,hashToRelated:c}),this._addRelatedBlankNodeHash({quad:I,component:I.graph,position:"g",id:n,issuer:t,hashToRelated:c});return c}_hashAndTrackBlankNode({id:n,hashToBlankNodes:t}){const c=this.hashFirstDegreeQuads(n),w=t.get(c);w?w.push(n):t.set(c,[n])}_addBlankNodeQuadInfo({quad:n,component:t}){if(t.termType!=="BlankNode")return;const c=t.value,w=this.blankNodeInfo.get(c);w?w.quads.add(n):this.blankNodeInfo.set(c,{quads:new Set([n]),hash:null})}_addRelatedBlankNodeHash({quad:n,component:t,position:c,id:w,issuer:I,hashToRelated:R}){if(!(t.termType==="BlankNode"&&t.value!==w))return;const u=t.value,m=this.hashRelatedBlankNode(u,n,I,c),E=R.get(m);E?E.push(u):R.set(m,[u])}_componentWithCanonicalId(n){return n.termType==="BlankNode"&&!n.value.startsWith(this.canonicalIssuer.prefix)?{termType:"BlankNode",value:this.canonicalIssuer.getId(n.value)}:n}};function O(i,n){return i.hash<n.hash?-1:i.hash>n.hash?1:0}return we}var ut;function Kt(){return ut||(ut=1,(function(v){const r=Ct(),y=Wt();function b(n,t){if(t.inputFormat){if(t.inputFormat==="application/n-quads"){if(typeof n!="string")throw new Error("N-Quads input must be a string.");return v.NQuads.parse(n)}throw new Error(`Unknown canonicalization input format: "${t.inputFormat}".`)}return n}function O(n){if(n.format&&n.format!=="application/n-quads")throw new Error(`Unknown canonicalization output format: "${n.format}".`)}function i(){globalThis.RDF_CANONIZE_TRACE_URDNA2015&&console.trace("[rdf-canonize] URDNA2015 is deprecated, use RDFC-1.0")}v.NQuads=Ke(),v.IdentifierIssuer=We(),v.canonize=async function(n,t={}){const c=b(n,t);if(O(t),!("algorithm"in t))throw new Error("No RDF Dataset Canonicalization algorithm specified.");if(t.algorithm==="RDFC-1.0")return new r(t).main(c);if(t.algorithm==="URDNA2015"&&!t.rejectURDNA2015)return i(),new r(t).main(c);throw new Error("Invalid RDF Dataset Canonicalization algorithm: "+t.algorithm)},v._canonizeSync=function(n,t={}){const c=b(n,t);if(O(t),!("algorithm"in t))throw new Error("No RDF Dataset Canonicalization algorithm specified.");if(t.algorithm==="RDFC-1.0")return new y(t).main(c);if(t.algorithm==="URDNA2015"&&!t.rejectURDNA2015)return i(),new y(t).main(c);throw new Error("Invalid RDF Dataset Canonicalization algorithm: "+t.algorithm)}})(he)),he}var Ie,dt;function Ye(){return dt||(dt=1,Ie=Kt()),Ie}var xe,ft;function ee(){if(ft)return xe;ft=1;const v={};return xe=v,v.isArray=Array.isArray,v.isBoolean=r=>typeof r=="boolean"||Object.prototype.toString.call(r)==="[object Boolean]",v.isDouble=r=>v.isNumber(r)&&(String(r).indexOf(".")!==-1||Math.abs(r)>=1e21),v.isEmptyObject=r=>v.isObject(r)&&Object.keys(r).length===0,v.isNumber=r=>typeof r=="number"||Object.prototype.toString.call(r)==="[object Number]",v.isNumeric=r=>!isNaN(parseFloat(r))&&isFinite(r),v.isObject=r=>Object.prototype.toString.call(r)==="[object Object]",v.isString=r=>typeof r=="string"||Object.prototype.toString.call(r)==="[object String]",v.isUndefined=r=>typeof r>"u",xe}var Ee,ht;function re(){if(ht)return Ee;ht=1;const v=ee(),r={};return Ee=r,r.isSubject=y=>v.isObject(y)&&!("@value"in y||"@set"in y||"@list"in y)?Object.keys(y).length>1||!("@id"in y):!1,r.isSubjectReference=y=>v.isObject(y)&&Object.keys(y).length===1&&"@id"in y,r.isValue=y=>v.isObject(y)&&"@value"in y,r.isList=y=>v.isObject(y)&&"@list"in y,r.isGraph=y=>v.isObject(y)&&"@graph"in y&&Object.keys(y).filter(b=>b!=="@id"&&b!=="@index").length===1,r.isSimpleGraph=y=>r.isGraph(y)&&!("@id"in y),r.isBlankNode=y=>{if(v.isObject(y)){if("@id"in y){const b=y["@id"];return!v.isString(b)||b.indexOf("_:")===0}return Object.keys(y).length===0||!("@value"in y||"@set"in y||"@list"in y)}return!1},Ee}var _e,pt;function ne(){return pt||(pt=1,_e=class extends Error{constructor(r="An unspecified JSON-LD error occurred.",y="jsonld.Error",b={}){super(r),this.name=y,this.message=r,this.details=b}}),_e}var Se,gt;function te(){if(gt)return Se;gt=1;const v=re(),r=ee(),y=Ye().IdentifierIssuer,b=ne(),O=/^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/,i=/(?:<[^>]*?>|"[^"]*?"|[^,])+/g,n=/\s*<([^>]*?)>\s*(?:;\s*(.*))?/,t=/(.*?)=(?:(?:"([^"]*?)")|([^"]*?))\s*(?:(?:;\s*)|$)/g,c=/^@[a-zA-Z]+$/,w={headers:{accept:"application/ld+json, application/json"}},I={};Se=I,I.IdentifierIssuer=y,I.REGEX_BCP47=O,I.REGEX_KEYWORD=c,I.clone=function(u){if(u&&typeof u=="object"){let m;if(r.isArray(u)){m=[];for(let E=0;E<u.length;++E)m[E]=I.clone(u[E])}else if(u instanceof Map){m=new Map;for(const[E,N]of u)m.set(E,I.clone(N))}else if(u instanceof Set){m=new Set;for(const E of u)m.add(I.clone(E))}else if(r.isObject(u)){m={};for(const E in u)m[E]=I.clone(u[E])}else m=u.toString();return m}return u},I.asArray=function(u){return Array.isArray(u)?u:[u]},I.buildHeaders=(u={})=>{if(Object.keys(u).some(E=>E.toLowerCase()==="accept"))throw new RangeError('Accept header may not be specified; only "'+w.headers.accept+'" is supported.');return Object.assign({Accept:w.headers.accept},u)},I.parseLinkHeader=u=>{const m={},E=u.match(i);for(let N=0;N<E.length;++N){let F=E[N].match(n);if(!F)continue;const B={target:F[1]},J=F[2];for(;F=t.exec(J);)B[F[1]]=F[2]===void 0?F[3]:F[2];const l=B.rel||"";Array.isArray(m[l])?m[l].push(B):m.hasOwnProperty(l)?m[l]=[m[l],B]:m[l]=B}return m},I.validateTypeValue=(u,m)=>{if(!r.isString(u)&&!(r.isArray(u)&&u.every(E=>r.isString(E)))){if(m&&r.isObject(u))switch(Object.keys(u).length){case 0:return;case 1:if("@default"in u&&I.asArray(u["@default"]).every(E=>r.isString(E)))return}throw new b('Invalid JSON-LD syntax; "@type" value must a string, an array of strings, an empty object, or a default object.',"jsonld.SyntaxError",{code:"invalid type value",value:u})}},I.hasProperty=(u,m)=>{if(u.hasOwnProperty(m)){const E=u[m];return!r.isArray(E)||E.length>0}return!1},I.hasValue=(u,m,E)=>{if(I.hasProperty(u,m)){let N=u[m];const F=v.isList(N);if(r.isArray(N)||F){F&&(N=N["@list"]);for(let B=0;B<N.length;++B)if(I.compareValues(E,N[B]))return!0}else if(!r.isArray(E))return I.compareValues(E,N)}return!1},I.addValue=(u,m,E,N)=>{if(N=N||{},"propertyIsArray"in N||(N.propertyIsArray=!1),"valueIsArray"in N||(N.valueIsArray=!1),"allowDuplicate"in N||(N.allowDuplicate=!0),"prependValue"in N||(N.prependValue=!1),N.valueIsArray)u[m]=E;else if(r.isArray(E)){E.length===0&&N.propertyIsArray&&!u.hasOwnProperty(m)&&(u[m]=[]),N.prependValue&&(E=E.concat(u[m]),u[m]=[]);for(let F=0;F<E.length;++F)I.addValue(u,m,E[F],N)}else if(u.hasOwnProperty(m)){const F=!N.allowDuplicate&&I.hasValue(u,m,E);!r.isArray(u[m])&&(!F||N.propertyIsArray)&&(u[m]=[u[m]]),F||(N.prependValue?u[m].unshift(E):u[m].push(E))}else u[m]=N.propertyIsArray?[E]:E},I.getValues=(u,m)=>[].concat(u[m]||[]),I.removeProperty=(u,m)=>{delete u[m]},I.removeValue=(u,m,E,N)=>{N=N||{},"propertyIsArray"in N||(N.propertyIsArray=!1);const F=I.getValues(u,m).filter(B=>!I.compareValues(B,E));F.length===0?I.removeProperty(u,m):F.length===1&&!N.propertyIsArray?u[m]=F[0]:u[m]=F},I.relabelBlankNodes=(u,m)=>{m=m||{};const E=m.issuer||new y("_:b");return R(E,u)},I.compareValues=(u,m)=>u===m||v.isValue(u)&&v.isValue(m)&&u["@value"]===m["@value"]&&u["@type"]===m["@type"]&&u["@language"]===m["@language"]&&u["@index"]===m["@index"]?!0:r.isObject(u)&&"@id"in u&&r.isObject(m)&&"@id"in m?u["@id"]===m["@id"]:!1,I.compareShortestLeast=(u,m)=>u.length<m.length?-1:m.length<u.length?1:u===m?0:u<m?-1:1;function R(u,m){if(r.isArray(m))for(let E=0;E<m.length;++E)m[E]=R(u,m[E]);else if(v.isList(m))m["@list"]=R(u,m["@list"]);else if(r.isObject(m)){v.isBlankNode(m)&&(m["@id"]=u.getId(m["@id"]));const E=Object.keys(m).sort();for(let N=0;N<E.length;++N){const F=E[N];F!=="@id"&&(m[F]=R(u,m[F]))}}return m}return Se}var Ne,yt;function Ze(){if(yt)return Ne;yt=1;const v="http://www.w3.org/1999/02/22-rdf-syntax-ns#",r="http://www.w3.org/2001/XMLSchema#";return Ne={LINK_HEADER_REL:"http://www.w3.org/ns/json-ld#context",LINK_HEADER_CONTEXT:"http://www.w3.org/ns/json-ld#context",RDF:v,RDF_LIST:v+"List",RDF_FIRST:v+"first",RDF_REST:v+"rest",RDF_NIL:v+"nil",RDF_TYPE:v+"type",RDF_PLAIN_LITERAL:v+"PlainLiteral",RDF_XML_LITERAL:v+"XMLLiteral",RDF_JSON_LITERAL:v+"JSON",RDF_OBJECT:v+"object",RDF_LANGSTRING:v+"langString",XSD:r,XSD_BOOLEAN:r+"boolean",XSD_DOUBLE:r+"double",XSD_INTEGER:r+"integer",XSD_STRING:r+"string"},Ne}var je,mt;function Vt(){return mt||(mt=1,je=class{constructor(){this._requests={}}wrapLoader(r){const y=this;return y._loader=r,function(){return y.add.apply(y,arguments)}}async add(r){let y=this._requests[r];if(y)return Promise.resolve(y);y=this._requests[r]=this._loader(r);try{return await y}finally{delete this._requests[r]}}}),je}var Re,vt;function ie(){if(vt)return Re;vt=1;const v=ee(),r={};Re=r,r.parsers={simple:{keys:["href","scheme","authority","path","query","fragment"],regex:/^(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/},full:{keys:["href","protocol","scheme","authority","auth","user","password","hostname","port","path","directory","file","query","fragment"],regex:/^(([a-zA-Z][a-zA-Z0-9+-.]*):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?(?:(((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/}},r.parse=(b,O)=>{const i={},n=r.parsers[O||"full"],t=n.regex.exec(b);let c=n.keys.length;for(;c--;)i[n.keys[c]]=t[c]===void 0?null:t[c];return(i.scheme==="https"&&i.port==="443"||i.scheme==="http"&&i.port==="80")&&(i.href=i.href.replace(":"+i.port,""),i.authority=i.authority.replace(":"+i.port,""),i.port=null),i.normalizedPath=r.removeDotSegments(i.path),i},r.prependBase=(b,O)=>{if(b===null||r.isAbsolute(O))return O;(!b||v.isString(b))&&(b=r.parse(b||""));const i=r.parse(O),n={protocol:b.protocol||""};if(i.authority!==null)n.authority=i.authority,n.path=i.path,n.query=i.query;else if(n.authority=b.authority,i.path==="")n.path=b.path,i.query!==null?n.query=i.query:n.query=b.query;else{if(i.path.indexOf("/")===0)n.path=i.path;else{let c=b.path;c=c.substr(0,c.lastIndexOf("/")+1),(c.length>0||b.authority)&&c.substr(-1)!=="/"&&(c+="/"),c+=i.path,n.path=c}n.query=i.query}i.path!==""&&(n.path=r.removeDotSegments(n.path));let t=n.protocol;return n.authority!==null&&(t+="//"+n.authority),t+=n.path,n.query!==null&&(t+="?"+n.query),i.fragment!==null&&(t+="#"+i.fragment),t===""&&(t="./"),t},r.removeBase=(b,O)=>{if(b===null)return O;(!b||v.isString(b))&&(b=r.parse(b||""));let i="";if(b.href!==""?i+=(b.protocol||"")+"//"+(b.authority||""):O.indexOf("//")&&(i+="//"),O.indexOf(i)!==0)return O;const n=r.parse(O.substr(i.length)),t=b.normalizedPath.split("/"),c=n.normalizedPath.split("/"),w=n.fragment||n.query?0:1;for(;t.length>0&&c.length>w&&t[0]===c[0];)t.shift(),c.shift();let I="";if(t.length>0){t.pop();for(let R=0;R<t.length;++R)I+="../"}return I+=c.join("/"),n.query!==null&&(I+="?"+n.query),n.fragment!==null&&(I+="#"+n.fragment),I===""&&(I="./"),I},r.removeDotSegments=b=>{if(b.length===0)return"";const O=b.split("/"),i=[];for(;O.length>0;){const n=O.shift(),t=O.length===0;if(n==="."){t&&i.push("");continue}if(n===".."){i.pop(),t&&i.push("");continue}i.push(n)}return b[0]==="/"&&i.length>0&&i[0]!==""&&i.unshift(""),i.length===1&&i[0]===""?"/":i.join("/")};const y=/^([A-Za-z][A-Za-z0-9+-.]*|_):[^\s]*$/;return r.isAbsolute=b=>v.isString(b)&&y.test(b),r.isRelative=b=>v.isString(b),Re}var De,bt;function Yt(){if(bt)return De;bt=1;const{parseLinkHeader:v,buildHeaders:r}=te(),{LINK_HEADER_CONTEXT:y}=Ze(),b=ne(),O=Vt(),{prependBase:i}=ie(),n=/(^|(\r\n))link:/i;De=({secure:c,headers:w={},xhr:I}={headers:{}})=>{return w=r(w),new O().wrapLoader(u);async function u(m){if(m.indexOf("http:")!==0&&m.indexOf("https:")!==0)throw new b('URL could not be dereferenced; only "http" and "https" URLs are supported.',"jsonld.InvalidUrl",{code:"loading document failed",url:m});if(c&&m.indexOf("https")!==0)throw new b(`URL could not be dereferenced; secure mode is enabled and the URL's scheme is not "https".`,"jsonld.InvalidUrl",{code:"loading document failed",url:m});let E;try{E=await t(I,m,w)}catch(l){throw new b("URL could not be dereferenced, an error occurred.","jsonld.LoadDocumentError",{code:"loading document failed",url:m,cause:l})}if(E.status>=400)throw new b("URL could not be dereferenced: "+E.statusText,"jsonld.LoadDocumentError",{code:"loading document failed",url:m,httpStatusCode:E.status});let N={contextUrl:null,documentUrl:m,document:E.response},F=null;const B=E.getResponseHeader("Content-Type");let J;if(n.test(E.getAllResponseHeaders())&&(J=E.getResponseHeader("Link")),J&&B!=="application/ld+json"){const l=v(J),e=l[y];if(Array.isArray(e))throw new b("URL could not be dereferenced, it has more than one associated HTTP Link Header.","jsonld.InvalidUrl",{code:"multiple context link headers",url:m});e&&(N.contextUrl=e.target),F=l.alternate,F&&F.type=="application/ld+json"&&!(B||"").match(/^application\/(\w*\+)?json$/)&&(N=await u(i(m,F.target)))}return N}};function t(c,w,I){c=c||XMLHttpRequest;const R=new c;return new Promise((u,m)=>{R.onload=()=>u(R),R.onerror=E=>m(E),R.open("GET",w,!0);for(const E in I)R.setRequestHeader(E,I[E]);R.send()})}return De}var Oe,wt;function Zt(){if(wt)return Oe;wt=1;const v=Yt(),r={};return Oe=r,r.setupDocumentLoaders=function(y){typeof XMLHttpRequest<"u"&&(y.documentLoaders.xhr=v,y.useDocumentLoader("xhr"))},r.setupGlobals=function(y){typeof globalThis.JsonLdProcessor>"u"&&Object.defineProperty(globalThis,"JsonLdProcessor",{writable:!0,enumerable:!1,configurable:!0,value:y.JsonLdProcessor})},Oe}var Le,It;function en(){return It||(It=1,Le=function(v){v.prototype[Symbol.iterator]=function*(){for(let r=this.head;r;r=r.next)yield r.value}}),Le}var Ae,xt;function tn(){if(xt)return Ae;xt=1,Ae=v,v.Node=O,v.create=v;function v(i){var n=this;if(n instanceof v||(n=new v),n.tail=null,n.head=null,n.length=0,i&&typeof i.forEach=="function")i.forEach(function(w){n.push(w)});else if(arguments.length>0)for(var t=0,c=arguments.length;t<c;t++)n.push(arguments[t]);return n}v.prototype.removeNode=function(i){if(i.list!==this)throw new Error("removing node which does not belong to this list");var n=i.next,t=i.prev;return n&&(n.prev=t),t&&(t.next=n),i===this.head&&(this.head=n),i===this.tail&&(this.tail=t),i.list.length--,i.next=null,i.prev=null,i.list=null,n},v.prototype.unshiftNode=function(i){if(i!==this.head){i.list&&i.list.removeNode(i);var n=this.head;i.list=this,i.next=n,n&&(n.prev=i),this.head=i,this.tail||(this.tail=i),this.length++}},v.prototype.pushNode=function(i){if(i!==this.tail){i.list&&i.list.removeNode(i);var n=this.tail;i.list=this,i.prev=n,n&&(n.next=i),this.tail=i,this.head||(this.head=i),this.length++}},v.prototype.push=function(){for(var i=0,n=arguments.length;i<n;i++)y(this,arguments[i]);return this.length},v.prototype.unshift=function(){for(var i=0,n=arguments.length;i<n;i++)b(this,arguments[i]);return this.length},v.prototype.pop=function(){if(this.tail){var i=this.tail.value;return this.tail=this.tail.prev,this.tail?this.tail.next=null:this.head=null,this.length--,i}},v.prototype.shift=function(){if(this.head){var i=this.head.value;return this.head=this.head.next,this.head?this.head.prev=null:this.tail=null,this.length--,i}},v.prototype.forEach=function(i,n){n=n||this;for(var t=this.head,c=0;t!==null;c++)i.call(n,t.value,c,this),t=t.next},v.prototype.forEachReverse=function(i,n){n=n||this;for(var t=this.tail,c=this.length-1;t!==null;c--)i.call(n,t.value,c,this),t=t.prev},v.prototype.get=function(i){for(var n=0,t=this.head;t!==null&&n<i;n++)t=t.next;if(n===i&&t!==null)return t.value},v.prototype.getReverse=function(i){for(var n=0,t=this.tail;t!==null&&n<i;n++)t=t.prev;if(n===i&&t!==null)return t.value},v.prototype.map=function(i,n){n=n||this;for(var t=new v,c=this.head;c!==null;)t.push(i.call(n,c.value,this)),c=c.next;return t},v.prototype.mapReverse=function(i,n){n=n||this;for(var t=new v,c=this.tail;c!==null;)t.push(i.call(n,c.value,this)),c=c.prev;return t},v.prototype.reduce=function(i,n){var t,c=this.head;if(arguments.length>1)t=n;else if(this.head)c=this.head.next,t=this.head.value;else throw new TypeError("Reduce of empty list with no initial value");for(var w=0;c!==null;w++)t=i(t,c.value,w),c=c.next;return t},v.prototype.reduceReverse=function(i,n){var t,c=this.tail;if(arguments.length>1)t=n;else if(this.tail)c=this.tail.prev,t=this.tail.value;else throw new TypeError("Reduce of empty list with no initial value");for(var w=this.length-1;c!==null;w--)t=i(t,c.value,w),c=c.prev;return t},v.prototype.toArray=function(){for(var i=new Array(this.length),n=0,t=this.head;t!==null;n++)i[n]=t.value,t=t.next;return i},v.prototype.toArrayReverse=function(){for(var i=new Array(this.length),n=0,t=this.tail;t!==null;n++)i[n]=t.value,t=t.prev;return i},v.prototype.slice=function(i,n){n=n||this.length,n<0&&(n+=this.length),i=i||0,i<0&&(i+=this.length);var t=new v;if(n<i||n<0)return t;i<0&&(i=0),n>this.length&&(n=this.length);for(var c=0,w=this.head;w!==null&&c<i;c++)w=w.next;for(;w!==null&&c<n;c++,w=w.next)t.push(w.value);return t},v.prototype.sliceReverse=function(i,n){n=n||this.length,n<0&&(n+=this.length),i=i||0,i<0&&(i+=this.length);var t=new v;if(n<i||n<0)return t;i<0&&(i=0),n>this.length&&(n=this.length);for(var c=this.length,w=this.tail;w!==null&&c>n;c--)w=w.prev;for(;w!==null&&c>i;c--,w=w.prev)t.push(w.value);return t},v.prototype.splice=function(i,n,...t){i>this.length&&(i=this.length-1),i<0&&(i=this.length+i);for(var c=0,w=this.head;w!==null&&c<i;c++)w=w.next;for(var I=[],c=0;w&&c<n;c++)I.push(w.value),w=this.removeNode(w);w===null&&(w=this.tail),w!==this.head&&w!==this.tail&&(w=w.prev);for(var c=0;c<t.length;c++)w=r(this,w,t[c]);return I},v.prototype.reverse=function(){for(var i=this.head,n=this.tail,t=i;t!==null;t=t.prev){var c=t.prev;t.prev=t.next,t.next=c}return this.head=n,this.tail=i,this};function r(i,n,t){var c=n===i.head?new O(t,null,n,i):new O(t,n,n.next,i);return c.next===null&&(i.tail=c),c.prev===null&&(i.head=c),i.length++,c}function y(i,n){i.tail=new O(n,i.tail,null,i),i.head||(i.head=i.tail),i.length++}function b(i,n){i.head=new O(n,null,i.head,i),i.tail||(i.tail=i.head),i.length++}function O(i,n,t,c){if(!(this instanceof O))return new O(i,n,t,c);this.list=c,this.value=i,n?(n.next=this,this.prev=n):this.prev=null,t?(t.prev=this,this.next=t):this.next=null}try{en()(v)}catch{}return Ae}var Te,Et;function Gt(){if(Et)return Te;Et=1;const v=tn(),r=Symbol("max"),y=Symbol("length"),b=Symbol("lengthCalculator"),O=Symbol("allowStale"),i=Symbol("maxAge"),n=Symbol("dispose"),t=Symbol("noDisposeOnSet"),c=Symbol("lruList"),w=Symbol("cache"),I=Symbol("updateAgeOnGet"),R=()=>1;class u{constructor(e){if(typeof e=="number"&&(e={max:e}),e||(e={}),e.max&&(typeof e.max!="number"||e.max<0))throw new TypeError("max must be a non-negative number");this[r]=e.max||1/0;const s=e.length||R;if(this[b]=typeof s!="function"?R:s,this[O]=e.stale||!1,e.maxAge&&typeof e.maxAge!="number")throw new TypeError("maxAge must be a number");this[i]=e.maxAge||0,this[n]=e.dispose,this[t]=e.noDisposeOnSet||!1,this[I]=e.updateAgeOnGet||!1,this.reset()}set max(e){if(typeof e!="number"||e<0)throw new TypeError("max must be a non-negative number");this[r]=e||1/0,N(this)}get max(){return this[r]}set allowStale(e){this[O]=!!e}get allowStale(){return this[O]}set maxAge(e){if(typeof e!="number")throw new TypeError("maxAge must be a non-negative number");this[i]=e,N(this)}get maxAge(){return this[i]}set lengthCalculator(e){typeof e!="function"&&(e=R),e!==this[b]&&(this[b]=e,this[y]=0,this[c].forEach(s=>{s.length=this[b](s.value,s.key),this[y]+=s.length})),N(this)}get lengthCalculator(){return this[b]}get length(){return this[y]}get itemCount(){return this[c].length}rforEach(e,s){s=s||this;for(let d=this[c].tail;d!==null;){const T=d.prev;J(this,e,d,s),d=T}}forEach(e,s){s=s||this;for(let d=this[c].head;d!==null;){const T=d.next;J(this,e,d,s),d=T}}keys(){return this[c].toArray().map(e=>e.key)}values(){return this[c].toArray().map(e=>e.value)}reset(){this[n]&&this[c]&&this[c].length&&this[c].forEach(e=>this[n](e.key,e.value)),this[w]=new Map,this[c]=new v,this[y]=0}dump(){return this[c].map(e=>E(this,e)?!1:{k:e.key,v:e.value,e:e.now+(e.maxAge||0)}).toArray().filter(e=>e)}dumpLru(){return this[c]}set(e,s,d){if(d=d||this[i],d&&typeof d!="number")throw new TypeError("maxAge must be a number");const T=d?Date.now():0,o=this[b](s,e);if(this[w].has(e)){if(o>this[r])return F(this,this[w].get(e)),!1;const L=this[w].get(e).value;return this[n]&&(this[t]||this[n](e,L.value)),L.now=T,L.maxAge=d,L.value=s,this[y]+=o-L.length,L.length=o,this.get(e),N(this),!0}const g=new B(e,s,o,T,d);return g.length>this[r]?(this[n]&&this[n](e,s),!1):(this[y]+=g.length,this[c].unshift(g),this[w].set(e,this[c].head),N(this),!0)}has(e){if(!this[w].has(e))return!1;const s=this[w].get(e).value;return!E(this,s)}get(e){return m(this,e,!0)}peek(e){return m(this,e,!1)}pop(){const e=this[c].tail;return e?(F(this,e),e.value):null}del(e){F(this,this[w].get(e))}load(e){this.reset();const s=Date.now();for(let d=e.length-1;d>=0;d--){const T=e[d],o=T.e||0;if(o===0)this.set(T.k,T.v);else{const g=o-s;g>0&&this.set(T.k,T.v,g)}}}prune(){this[w].forEach((e,s)=>m(this,s,!1))}}const m=(l,e,s)=>{const d=l[w].get(e);if(d){const T=d.value;if(E(l,T)){if(F(l,d),!l[O])return}else s&&(l[I]&&(d.value.now=Date.now()),l[c].unshiftNode(d));return T.value}},E=(l,e)=>{if(!e||!e.maxAge&&!l[i])return!1;const s=Date.now()-e.now;return e.maxAge?s>e.maxAge:l[i]&&s>l[i]},N=l=>{if(l[y]>l[r])for(let e=l[c].tail;l[y]>l[r]&&e!==null;){const s=e.prev;F(l,e),e=s}},F=(l,e)=>{if(e){const s=e.value;l[n]&&l[n](s.key,s.value),l[y]-=s.length,l[w].delete(s.key),l[c].removeNode(e)}};class B{constructor(e,s,d,T,o){this.key=e,this.value=s,this.length=d,this.now=T,this.maxAge=o||0}}const J=(l,e,s,d)=>{let T=s.value;E(l,T)&&(F(l,s),l[O]||(T=void 0)),T&&e.call(d,T.value,T.key,l)};return Te=u,Te}var ke,_t;function nn(){if(_t)return ke;_t=1;const v=Gt(),r=10;return ke=class{constructor({document:b}){this.document=b,this.cache=new v({max:r})}getProcessed(b){return this.cache.get(b)}setProcessed(b,O){this.cache.set(b,O)}},ke}var Me,St;function rn(){if(St)return Me;St=1;const{isArray:v,isObject:r,isString:y}=ee(),{asArray:b}=te(),{prependBase:O}=ie(),i=ne(),n=nn(),t=10;Me=class{constructor({sharedCache:R}){this.perOpCache=new Map,this.sharedCache=R}async resolve({activeCtx:R,context:u,documentLoader:m,base:E,cycles:N=new Set}){u&&r(u)&&u["@context"]&&(u=u["@context"]),u=b(u);const F=[];for(const B of u){if(y(B)){let e=this._get(B);e||(e=await this._resolveRemoteContext({activeCtx:R,url:B,documentLoader:m,base:E,cycles:N})),v(e)?F.push(...e):F.push(e);continue}if(B===null){F.push(new n({document:null}));continue}r(B)||c(u);const J=JSON.stringify(B);let l=this._get(J);l||(l=new n({document:B}),this._cacheResolvedContext({key:J,resolved:l,tag:"static"})),F.push(l)}return F}_get(R){let u=this.perOpCache.get(R);if(!u){const m=this.sharedCache.get(R);m&&(u=m.get("static"),u&&this.perOpCache.set(R,u))}return u}_cacheResolvedContext({key:R,resolved:u,tag:m}){if(this.perOpCache.set(R,u),m!==void 0){let E=this.sharedCache.get(R);E||(E=new Map,this.sharedCache.set(R,E)),E.set(m,u)}return u}async _resolveRemoteContext({activeCtx:R,url:u,documentLoader:m,base:E,cycles:N}){u=O(E,u);const{context:F,remoteDoc:B}=await this._fetchContext({activeCtx:R,url:u,documentLoader:m,cycles:N});E=B.documentUrl||u,w({context:F,base:E});const J=await this.resolve({activeCtx:R,context:F,documentLoader:m,base:E,cycles:N});return this._cacheResolvedContext({key:u,resolved:J,tag:B.tag}),J}async _fetchContext({activeCtx:R,url:u,documentLoader:m,cycles:E}){if(E.size>t)throw new i("Maximum number of @context URLs exceeded.","jsonld.ContextUrlError",{code:R.processingMode==="json-ld-1.0"?"loading remote context failed":"context overflow",max:t});if(E.has(u))throw new i("Cyclical @context URLs detected.","jsonld.ContextUrlError",{code:R.processingMode==="json-ld-1.0"?"recursive context inclusion":"context overflow",url:u});E.add(u);let N,F;try{F=await m(u),N=F.document||null,y(N)&&(N=JSON.parse(N))}catch(B){throw new i(`Dereferencing a URL did not result in a valid JSON-LD object. Possible causes are an inaccessible URL perhaps due to a same-origin policy (ensure the server uses CORS if you are using client-side JavaScript), too many redirects, a non-JSON response, or more than one HTTP Link Header was provided for a remote context. URL: "${u}".`,"jsonld.InvalidUrl",{code:"loading remote context failed",url:u,cause:B})}if(!r(N))throw new i(`Dereferencing a URL did not result in a JSON object. The response was valid JSON, but it was not a JSON object. URL: "${u}".`,"jsonld.InvalidUrl",{code:"invalid remote context",url:u});return"@context"in N?N={"@context":N["@context"]}:N={"@context":{}},F.contextUrl&&(v(N["@context"])||(N["@context"]=[N["@context"]]),N["@context"].push(F.contextUrl)),{context:N,remoteDoc:F}}};function c(I){throw new i("Invalid JSON-LD syntax; @context must be an object.","jsonld.SyntaxError",{code:"invalid local context",context:I})}function w({context:I,base:R}){if(!I)return;const u=I["@context"];if(y(u)){I["@context"]=O(R,u);return}if(v(u)){for(let m=0;m<u.length;++m){const E=u[m];if(y(E)){u[m]=O(R,E);continue}r(E)&&w({context:{"@context":E},base:R})}return}if(r(u))for(const m in u)w({context:u[m],base:R})}return Me}var Fe,Nt;function sn(){return Nt||(Nt=1,Fe=Ye().NQuads),Fe}var qe,jt;function oe(){if(jt)return qe;jt=1;const v=ne(),{isArray:r}=ee(),{asArray:y}=te(),b={};qe=b,b.defaultEventHandler=null,b.setupEventHandler=({options:n={}})=>{const t=[].concat(n.safe?b.safeEventHandler:[],n.eventHandler?y(n.eventHandler):[],b.defaultEventHandler?b.defaultEventHandler:[]);return t.length===0?null:t},b.handleEvent=({event:n,options:t})=>{O({event:n,handlers:t.eventHandler})};function O({event:n,handlers:t}){let c=!0;for(let w=0;c&&w<t.length;++w){c=!1;const I=t[w];if(r(I))c=O({event:n,handlers:I});else if(typeof I=="function")I({event:n,next:()=>{c=!0}});else if(typeof I=="object")n.code in I?I[n.code]({event:n,next:()=>{c=!0}}):c=!0;else throw new v("Invalid event handler.","jsonld.InvalidEventHandler",{event:n})}return c}const i=new Set(["empty object","free-floating scalar","invalid @language value","invalid property","null @id value","null @value value","object with only @id","object with only @language","object with only @list","object with only @value","relative @id reference","relative @type reference","relative @vocab reference","reserved @id value","reserved @reverse value","reserved term","blank node predicate","relative graph reference","relative object reference","relative predicate reference","relative subject reference","rdfDirection not set"]);return b.safeEventHandler=function({event:t,next:c}){if(t.level==="warning"&&i.has(t.code))throw new v("Safe mode validation error.","jsonld.ValidationError",{event:t});c()},b.logEventHandler=function({event:t,next:c}){console.log(`EVENT: ${t.message}`,{event:t}),c()},b.logWarningEventHandler=function({event:t,next:c}){t.level==="warning"&&console.warn(`WARNING: ${t.message}`,{event:t}),c()},b.unhandledEventHandler=function({event:t}){throw new v("No handler for event.","jsonld.UnhandledEvent",{event:t})},b.setDefaultEventHandler=function({eventHandler:n}={}){b.defaultEventHandler=n?y(n):null},qe}var Je,Rt;function se(){if(Rt)return Je;Rt=1;const v=te(),r=ne(),{isArray:y,isObject:b,isString:O,isUndefined:i}=ee(),{isAbsolute:n,isRelative:t,prependBase:c}=ie(),{handleEvent:w}=oe(),{REGEX_BCP47:I,REGEX_KEYWORD:R,asArray:u,compareShortestLeast:m}=te(),E=new Map,N=1e4,F={};Je=F,F.process=async({activeCtx:l,localCtx:e,options:s,propagate:d=!0,overrideProtected:T=!1,cycles:o=new Set})=>{if(b(e)&&"@context"in e&&y(e["@context"])&&(e=e["@context"]),u(e).length===0)return l;const f=[],L=[({event:q,next:a})=>{f.push(q),a()}];s.eventHandler&&L.push(s.eventHandler);const M=s;s={...s,eventHandler:L};const D=await s.contextResolver.resolve({activeCtx:l,context:e,documentLoader:s.documentLoader,base:s.base});b(D[0].document)&&typeof D[0].document["@propagate"]=="boolean"&&(d=D[0].document["@propagate"]);let h=l;!d&&!h.previousContext&&(h=h.clone(),h.previousContext=l);for(const q of D){let{document:a}=q;if(l=h,a===null){if(!T&&Object.keys(l.protected).length!==0)throw new r("Tried to nullify a context with protected terms outside of a term definition.","jsonld.SyntaxError",{code:"invalid context nullification"});h=l=F.getInitialContext(s).clone();continue}const j=q.getProcessed(l);if(j){if(M.eventHandler)for(const k of j.events)w({event:k,options:M});h=l=j.context;continue}if(b(a)&&"@context"in a&&(a=a["@context"]),!b(a))throw new r("Invalid JSON-LD syntax; @context must be an object.","jsonld.SyntaxError",{code:"invalid local context",context:a});h=h.clone();const A=new Map;if("@version"in a){if(a["@version"]!==1.1)throw new r("Unsupported JSON-LD version: "+a["@version"],"jsonld.UnsupportedVersion",{code:"invalid @version value",context:a});if(l.processingMode&&l.processingMode==="json-ld-1.0")throw new r("@version: "+a["@version"]+" not compatible with "+l.processingMode,"jsonld.ProcessingModeConflict",{code:"processing mode conflict",context:a});h.processingMode="json-ld-1.1",h["@version"]=a["@version"],A.set("@version",!0)}if(h.processingMode=h.processingMode||l.processingMode,"@base"in a){let k=a["@base"];if(!(k===null||n(k)))if(t(k))k=c(h["@base"],k);else throw new r('Invalid JSON-LD syntax; the value of "@base" in a @context must be an absolute IRI, a relative IRI, or null.',"jsonld.SyntaxError",{code:"invalid base IRI",context:a});h["@base"]=k,A.set("@base",!0)}if("@vocab"in a){const k=a["@vocab"];if(k===null)delete h["@vocab"];else if(O(k)){if(!n(k)&&F.processingMode(h,1))throw new r('Invalid JSON-LD syntax; the value of "@vocab" in a @context must be an absolute IRI.',"jsonld.SyntaxError",{code:"invalid vocab mapping",context:a});{const p=B(h,k,{vocab:!0,base:!0},void 0,void 0,s);n(p)||s.eventHandler&&w({event:{type:["JsonLdEvent"],code:"relative @vocab reference",level:"warning",message:"Relative @vocab reference found.",details:{vocab:p}},options:s}),h["@vocab"]=p}}else throw new r('Invalid JSON-LD syntax; the value of "@vocab" in a @context must be a string or null.',"jsonld.SyntaxError",{code:"invalid vocab mapping",context:a});A.set("@vocab",!0)}if("@language"in a){const k=a["@language"];if(k===null)delete h["@language"];else if(O(k))k.match(I)||s.eventHandler&&w({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:k}},options:s}),h["@language"]=k.toLowerCase();else throw new r('Invalid JSON-LD syntax; the value of "@language" in a @context must be a string or null.',"jsonld.SyntaxError",{code:"invalid default language",context:a});A.set("@language",!0)}if("@direction"in a){const k=a["@direction"];if(l.processingMode==="json-ld-1.0")throw new r("Invalid JSON-LD syntax; @direction not compatible with "+l.processingMode,"jsonld.SyntaxError",{code:"invalid context member",context:a});if(k===null)delete h["@direction"];else{if(k!=="ltr"&&k!=="rtl")throw new r('Invalid JSON-LD syntax; the value of "@direction" in a @context must be null, "ltr", or "rtl".',"jsonld.SyntaxError",{code:"invalid base direction",context:a});h["@direction"]=k}A.set("@direction",!0)}if("@propagate"in a){const k=a["@propagate"];if(l.processingMode==="json-ld-1.0")throw new r("Invalid JSON-LD syntax; @propagate not compatible with "+l.processingMode,"jsonld.SyntaxError",{code:"invalid context entry",context:a});if(typeof k!="boolean")throw new r("Invalid JSON-LD syntax; @propagate value must be a boolean.","jsonld.SyntaxError",{code:"invalid @propagate value",context:e});A.set("@propagate",!0)}if("@import"in a){const k=a["@import"];if(l.processingMode==="json-ld-1.0")throw new r("Invalid JSON-LD syntax; @import not compatible with "+l.processingMode,"jsonld.SyntaxError",{code:"invalid context entry",context:a});if(!O(k))throw new r("Invalid JSON-LD syntax; @import must be a string.","jsonld.SyntaxError",{code:"invalid @import value",context:e});const p=await s.contextResolver.resolve({activeCtx:l,context:k,documentLoader:s.documentLoader,base:s.base});if(p.length!==1)throw new r("Invalid JSON-LD syntax; @import must reference a single context.","jsonld.SyntaxError",{code:"invalid remote context",context:e});const G=p[0].getProcessed(l);if(G)a=G;else{const H=p[0].document;if("@import"in H)throw new r("Invalid JSON-LD syntax: imported context must not include @import.","jsonld.SyntaxError",{code:"invalid context entry",context:e});for(const V in H)a.hasOwnProperty(V)||(a[V]=H[V]);p[0].setProcessed(l,a)}A.set("@import",!0)}A.set("@protected",a["@protected"]||!1);for(const k in a)if(F.createTermDefinition({activeCtx:h,localCtx:a,term:k,defined:A,options:s,overrideProtected:T}),b(a[k])&&"@context"in a[k]){const p=a[k]["@context"];let G=!0;if(O(p)){const H=c(s.base,p);o.has(H)?G=!1:o.add(H)}if(G)try{await F.process({activeCtx:h.clone(),localCtx:a[k]["@context"],overrideProtected:!0,options:s,cycles:o})}catch{throw new r("Invalid JSON-LD syntax; invalid scoped context.","jsonld.SyntaxError",{code:"invalid scoped context",context:a[k]["@context"],term:k})}}q.setProcessed(l,{context:h,events:f})}return h},F.createTermDefinition=({activeCtx:l,localCtx:e,term:s,defined:d,options:T,overrideProtected:o=!1})=>{if(d.has(s)){if(d.get(s))return;throw new r("Cyclical context definition detected.","jsonld.CyclicalContext",{code:"cyclic IRI mapping",context:e,term:s})}d.set(s,!1);let g;if(e.hasOwnProperty(s)&&(g=e[s]),s==="@type"&&b(g)&&(g["@container"]||"@set")==="@set"&&F.processingMode(l,1.1)){const a=["@container","@id","@protected"],j=Object.keys(g);if(j.length===0||j.some(A=>!a.includes(A)))throw new r("Invalid JSON-LD syntax; keywords cannot be overridden.","jsonld.SyntaxError",{code:"keyword redefinition",context:e,term:s})}else{if(F.isKeyword(s))throw new r("Invalid JSON-LD syntax; keywords cannot be overridden.","jsonld.SyntaxError",{code:"keyword redefinition",context:e,term:s});if(s.match(R)){T.eventHandler&&w({event:{type:["JsonLdEvent"],code:"reserved term",level:"warning",message:'Terms beginning with "@" are reserved for future use and dropped.',details:{term:s}},options:T});return}else if(s==="")throw new r("Invalid JSON-LD syntax; a term cannot be an empty string.","jsonld.SyntaxError",{code:"invalid term definition",context:e})}const f=l.mappings.get(s);l.mappings.has(s)&&l.mappings.delete(s);let L=!1;if((O(g)||g===null)&&(L=!0,g={"@id":g}),!b(g))throw new r("Invalid JSON-LD syntax; @context term values must be strings or objects.","jsonld.SyntaxError",{code:"invalid term definition",context:e});const M={};l.mappings.set(s,M),M.reverse=!1;const D=["@container","@id","@language","@reverse","@type"];F.processingMode(l,1.1)&&D.push("@context","@direction","@index","@nest","@prefix","@protected");for(const a in g)if(!D.includes(a))throw new r("Invalid JSON-LD syntax; a term definition must not contain "+a,"jsonld.SyntaxError",{code:"invalid term definition",context:e});const h=s.indexOf(":");if(M._termHasColon=h>0,"@reverse"in g){if("@id"in g)throw new r("Invalid JSON-LD syntax; a @reverse term definition must not contain @id.","jsonld.SyntaxError",{code:"invalid reverse property",context:e});if("@nest"in g)throw new r("Invalid JSON-LD syntax; a @reverse term definition must not contain @nest.","jsonld.SyntaxError",{code:"invalid reverse property",context:e});const a=g["@reverse"];if(!O(a))throw new r("Invalid JSON-LD syntax; a @context @reverse value must be a string.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:e});if(a.match(R)){T.eventHandler&&w({event:{type:["JsonLdEvent"],code:"reserved @reverse value",level:"warning",message:'@reverse values beginning with "@" are reserved for future use and dropped.',details:{reverse:a}},options:T}),f?l.mappings.set(s,f):l.mappings.delete(s);return}const j=B(l,a,{vocab:!0,base:!1},e,d,T);if(!n(j))throw new r("Invalid JSON-LD syntax; a @context @reverse value must be an absolute IRI or a blank node identifier.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:e});M["@id"]=j,M.reverse=!0}else if("@id"in g){let a=g["@id"];if(a&&!O(a))throw new r("Invalid JSON-LD syntax; a @context @id value must be an array of strings or a string.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:e});if(a===null)M["@id"]=null;else if(!F.isKeyword(a)&&a.match(R)){T.eventHandler&&w({event:{type:["JsonLdEvent"],code:"reserved @id value",level:"warning",message:'@id values beginning with "@" are reserved for future use and dropped.',details:{id:a}},options:T}),f?l.mappings.set(s,f):l.mappings.delete(s);return}else if(a!==s){if(a=B(l,a,{vocab:!0,base:!1},e,d,T),!n(a)&&!F.isKeyword(a))throw new r("Invalid JSON-LD syntax; a @context @id value must be an absolute IRI, a blank node identifier, or a keyword.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:e});if(s.match(/(?::[^:])|\//)){const j=new Map(d).set(s,!0);if(B(l,s,{vocab:!0,base:!1},e,j,T)!==a)throw new r("Invalid JSON-LD syntax; term in form of IRI must expand to definition.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:e})}M["@id"]=a,M._prefix=L&&!M._termHasColon&&a.match(/[:\/\?#\[\]@]$/)!==null}}if(!("@id"in M))if(M._termHasColon){const a=s.substr(0,h);if(e.hasOwnProperty(a)&&F.createTermDefinition({activeCtx:l,localCtx:e,term:a,defined:d,options:T}),l.mappings.has(a)){const j=s.substr(h+1);M["@id"]=l.mappings.get(a)["@id"]+j}else M["@id"]=s}else if(s==="@type")M["@id"]=s;else{if(!("@vocab"in l))throw new r("Invalid JSON-LD syntax; @context terms must define an @id.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:e,term:s});M["@id"]=l["@vocab"]+s}if((g["@protected"]===!0||d.get("@protected")===!0&&g["@protected"]!==!1)&&(l.protected[s]=!0,M.protected=!0),d.set(s,!0),"@type"in g){let a=g["@type"];if(!O(a))throw new r("Invalid JSON-LD syntax; an @context @type value must be a string.","jsonld.SyntaxError",{code:"invalid type mapping",context:e});if(a==="@json"||a==="@none"){if(F.processingMode(l,1))throw new r(`Invalid JSON-LD syntax; an @context @type value must not be "${a}" in JSON-LD 1.0 mode.`,"jsonld.SyntaxError",{code:"invalid type mapping",context:e})}else if(a!=="@id"&&a!=="@vocab"){if(a=B(l,a,{vocab:!0,base:!1},e,d,T),!n(a))throw new r("Invalid JSON-LD syntax; an @context @type value must be an absolute IRI.","jsonld.SyntaxError",{code:"invalid type mapping",context:e});if(a.indexOf("_:")===0)throw new r("Invalid JSON-LD syntax; an @context @type value must be an IRI, not a blank node identifier.","jsonld.SyntaxError",{code:"invalid type mapping",context:e})}M["@type"]=a}if("@container"in g){const a=O(g["@container"])?[g["@container"]]:g["@container"]||[],j=["@list","@set","@index","@language"];let A=!0;const k=a.includes("@set");if(F.processingMode(l,1.1)){if(j.push("@graph","@id","@type"),a.includes("@list")){if(a.length!==1)throw new r("Invalid JSON-LD syntax; @context @container with @list must have no other values","jsonld.SyntaxError",{code:"invalid container mapping",context:e})}else if(a.includes("@graph")){if(a.some(p=>p!=="@graph"&&p!=="@id"&&p!=="@index"&&p!=="@set"))throw new r("Invalid JSON-LD syntax; @context @container with @graph must have no other values other than @id, @index, and @set","jsonld.SyntaxError",{code:"invalid container mapping",context:e})}else A&=a.length<=(k?2:1);if(a.includes("@type")&&(M["@type"]=M["@type"]||"@id",!["@id","@vocab"].includes(M["@type"])))throw new r("Invalid JSON-LD syntax; container: @type requires @type to be @id or @vocab.","jsonld.SyntaxError",{code:"invalid type mapping",context:e})}else A&=!y(g["@container"]),A&=a.length<=1;if(A&=a.every(p=>j.includes(p)),A&=!(k&&a.includes("@list")),!A)throw new r("Invalid JSON-LD syntax; @context @container value must be one of the following: "+j.join(", "),"jsonld.SyntaxError",{code:"invalid container mapping",context:e});if(M.reverse&&!a.every(p=>["@index","@set"].includes(p)))throw new r("Invalid JSON-LD syntax; @context @container value for a @reverse type definition must be @index or @set.","jsonld.SyntaxError",{code:"invalid reverse property",context:e});M["@container"]=a}if("@index"in g){if(!("@container"in g)||!M["@container"].includes("@index"))throw new r(`Invalid JSON-LD syntax; @index without @index in @container: "${g["@index"]}" on term "${s}".`,"jsonld.SyntaxError",{code:"invalid term definition",context:e});if(!O(g["@index"])||g["@index"].indexOf("@")===0)throw new r(`Invalid JSON-LD syntax; @index must expand to an IRI: "${g["@index"]}" on term "${s}".`,"jsonld.SyntaxError",{code:"invalid term definition",context:e});M["@index"]=g["@index"]}if("@context"in g&&(M["@context"]=g["@context"]),"@language"in g&&!("@type"in g)){let a=g["@language"];if(a!==null&&!O(a))throw new r("Invalid JSON-LD syntax; @context @language value must be a string or null.","jsonld.SyntaxError",{code:"invalid language mapping",context:e});a!==null&&(a=a.toLowerCase()),M["@language"]=a}if("@prefix"in g){if(s.match(/:|\//))throw new r("Invalid JSON-LD syntax; @context @prefix used on a compact IRI term","jsonld.SyntaxError",{code:"invalid term definition",context:e});if(F.isKeyword(M["@id"]))throw new r("Invalid JSON-LD syntax; keywords may not be used as prefixes","jsonld.SyntaxError",{code:"invalid term definition",context:e});if(typeof g["@prefix"]=="boolean")M._prefix=g["@prefix"]===!0;else throw new r("Invalid JSON-LD syntax; @context value for @prefix must be boolean","jsonld.SyntaxError",{code:"invalid @prefix value",context:e})}if("@direction"in g){const a=g["@direction"];if(a!==null&&a!=="ltr"&&a!=="rtl")throw new r('Invalid JSON-LD syntax; @direction value must be null, "ltr", or "rtl".',"jsonld.SyntaxError",{code:"invalid base direction",context:e});M["@direction"]=a}if("@nest"in g){const a=g["@nest"];if(!O(a)||a!=="@nest"&&a.indexOf("@")===0)throw new r("Invalid JSON-LD syntax; @context @nest value must be a string which is not a keyword other than @nest.","jsonld.SyntaxError",{code:"invalid @nest value",context:e});M["@nest"]=a}const q=M["@id"];if(q==="@context"||q==="@preserve")throw new r("Invalid JSON-LD syntax; @context and @preserve cannot be aliased.","jsonld.SyntaxError",{code:"invalid keyword alias",context:e});if(f&&f.protected&&!o&&(l.protected[s]=!0,M.protected=!0,!J(f,M)))throw new r("Invalid JSON-LD syntax; tried to redefine a protected term.","jsonld.SyntaxError",{code:"protected term redefinition",context:e,term:s})},F.expandIri=(l,e,s,d)=>B(l,e,s,void 0,void 0,d);function B(l,e,s,d,T,o){if(e===null||!O(e)||F.isKeyword(e))return e;if(e.match(R))return null;if(d&&d.hasOwnProperty(e)&&T.get(e)!==!0&&F.createTermDefinition({activeCtx:l,localCtx:d,term:e,defined:T,options:o}),s=s||{},s.vocab){const f=l.mappings.get(e);if(f===null)return null;if(b(f)&&"@id"in f)return f["@id"]}const g=e.indexOf(":");if(g>0){const f=e.substr(0,g),L=e.substr(g+1);if(f==="_"||L.indexOf("//")===0)return e;d&&d.hasOwnProperty(f)&&F.createTermDefinition({activeCtx:l,localCtx:d,term:f,defined:T,options:o});const M=l.mappings.get(f);if(M&&M._prefix)return M["@id"]+L;if(n(e))return e}if(s.vocab&&"@vocab"in l)e=l["@vocab"]+e;else if(s.base){let f,L;"@base"in l?l["@base"]?(L=c(o.base,l["@base"]),f=c(L,e)):(L=l["@base"],f=e):(L=o.base,f=c(o.base,e)),e=f}return e}F.getInitialContext=l=>{const e=JSON.stringify({processingMode:l.processingMode}),s=E.get(e);if(s)return s;const d={processingMode:l.processingMode,mappings:new Map,inverse:null,getInverse:T,clone:f,revertToPreviousContext:L,protected:{}};return E.size===N&&E.clear(),E.set(e,d),d;function T(){const M=this;if(M.inverse)return M.inverse;const D=M.inverse={},h=M.fastCurieMap={},q={},a=(M["@language"]||"@none").toLowerCase(),j=M["@direction"],A=M.mappings,k=[...A.keys()].sort(m);for(const p of k){const G=A.get(p);if(G===null)continue;let H=G["@container"]||"@none";if(H=[].concat(H).sort().join(""),G["@id"]===null)continue;const V=u(G["@id"]);for(const X of V){let S=D[X];const x=F.isKeyword(X);if(S)!x&&!G._termHasColon&&q[X].push(p);else if(D[X]=S={},!x&&!G._termHasColon){q[X]=[p];const _={iri:X,terms:q[X]};X[0]in h?h[X[0]].push(_):h[X[0]]=[_]}if(S[H]||(S[H]={"@language":{},"@type":{},"@any":{}}),S=S[H],g(p,S["@any"],"@none"),G.reverse)g(p,S["@type"],"@reverse");else if(G["@type"]==="@none")g(p,S["@any"],"@none"),g(p,S["@language"],"@none"),g(p,S["@type"],"@none");else if("@type"in G)g(p,S["@type"],G["@type"]);else if("@language"in G&&"@direction"in G){const _=G["@language"],U=G["@direction"];_&&U?g(p,S["@language"],`${_}_${U}`.toLowerCase()):_?g(p,S["@language"],_.toLowerCase()):U?g(p,S["@language"],`_${U}`):g(p,S["@language"],"@null")}else"@language"in G?g(p,S["@language"],(G["@language"]||"@null").toLowerCase()):"@direction"in G?G["@direction"]?g(p,S["@language"],`_${G["@direction"]}`):g(p,S["@language"],"@none"):j?(g(p,S["@language"],`_${j}`),g(p,S["@language"],"@none"),g(p,S["@type"],"@none")):(g(p,S["@language"],a),g(p,S["@language"],"@none"),g(p,S["@type"],"@none"))}}for(const p in h)o(h,p,1);return D}function o(M,D,h){const q=M[D],a=M[D]={};let j,A;for(const k of q)j=k.iri,h>=j.length?A="":A=j[h],A in a?a[A].push(k):a[A]=[k];for(const k in a)k!==""&&o(a,k,h+1)}function g(M,D,h){D.hasOwnProperty(h)||(D[h]=M)}function f(){const M={};return M.mappings=v.clone(this.mappings),M.clone=this.clone,M.inverse=null,M.getInverse=this.getInverse,M.protected=v.clone(this.protected),this.previousContext&&(M.previousContext=this.previousContext.clone()),M.revertToPreviousContext=this.revertToPreviousContext,"@base"in this&&(M["@base"]=this["@base"]),"@language"in this&&(M["@language"]=this["@language"]),"@vocab"in this&&(M["@vocab"]=this["@vocab"]),M}function L(){return this.previousContext?this.previousContext.clone():this}},F.getContextValue=(l,e,s)=>{if(e===null)return s==="@context"?void 0:null;if(l.mappings.has(e)){const d=l.mappings.get(e);if(i(s))return d;if(d.hasOwnProperty(s))return d[s]}if(s==="@language"&&s in l||s==="@direction"&&s in l)return l[s];if(s!=="@context")return null},F.processingMode=(l,e)=>e.toString()>="1.1"?!l.processingMode||l.processingMode>="json-ld-"+e.toString():l.processingMode==="json-ld-1.0",F.isKeyword=l=>{if(!O(l)||l[0]!=="@")return!1;switch(l){case"@base":case"@container":case"@context":case"@default":case"@direction":case"@embed":case"@explicit":case"@graph":case"@id":case"@included":case"@index":case"@json":case"@language":case"@list":case"@nest":case"@none":case"@omitDefault":case"@prefix":case"@preserve":case"@protected":case"@requireAll":case"@reverse":case"@set":case"@type":case"@value":case"@version":case"@vocab":return!0}return!1};function J(l,e){if(!(l&&typeof l=="object")||!(e&&typeof e=="object"))return l===e;const s=Array.isArray(l);if(s!==Array.isArray(e))return!1;if(s){if(l.length!==e.length)return!1;for(let o=0;o<l.length;++o)if(!J(l[o],e[o]))return!1;return!0}const d=Object.keys(l),T=Object.keys(e);if(d.length!==T.length)return!1;for(const o in l){let g=l[o],f=e[o];if(o==="@container"&&Array.isArray(g)&&Array.isArray(f)&&(g=g.slice().sort(),f=f.slice().sort()),!J(g,f))return!1}return!0}return Je}var He,Dt;function an(){if(Dt)return He;Dt=1;const v=ne(),{isArray:r,isObject:y,isEmptyObject:b,isString:O,isUndefined:i}=ee(),{isList:n,isValue:t,isGraph:c,isSubject:w}=re(),{expandIri:I,getContextValue:R,isKeyword:u,process:m,processingMode:E}=se(),{isAbsolute:N}=ie(),{REGEX_BCP47:F,REGEX_KEYWORD:B,addValue:J,asArray:l,getValues:e,validateTypeValue:s}=te(),{handleEvent:d}=oe(),T={};He=T,T.expand=async({activeCtx:D,activeProperty:h=null,element:q,options:a={},insideList:j=!1,insideIndex:A=!1,typeScopedContext:k=null})=>{if(q==null)return null;if(h==="@default"&&(a=Object.assign({},a,{isFrame:!1})),!r(q)&&!y(q))return!j&&(h===null||I(D,h,{vocab:!0},a)==="@graph")?(a.eventHandler&&d({event:{type:["JsonLdEvent"],code:"free-floating scalar",level:"warning",message:"Dropping free-floating scalar not in a list.",details:{value:q}},options:a}),null):f({activeCtx:D,activeProperty:h,value:q,options:a});if(r(q)){let _=[];const U=R(D,h,"@container")||[];j=j||U.includes("@list");for(let z=0;z<q.length;++z){let P=await T.expand({activeCtx:D,activeProperty:h,element:q[z],options:a,insideIndex:A,typeScopedContext:k});j&&r(P)&&(P={"@list":P}),P!==null&&(r(P)?_=_.concat(P):_.push(P))}return _}const p=I(D,h,{vocab:!0},a),G=R(D,h,"@context");k=k||(D.previousContext?D:null);let H=Object.keys(q).sort(),V=!A;if(V&&k&&H.length<=2&&!H.includes("@context"))for(const _ of H){const U=I(k,_,{vocab:!0},a);if(U==="@value"){V=!1,D=k;break}if(U==="@id"&&H.length===1){V=!1;break}}V&&(D=D.revertToPreviousContext()),i(G)||(D=await m({activeCtx:D,localCtx:G,propagate:!0,overrideProtected:!0,options:a})),"@context"in q&&(D=await m({activeCtx:D,localCtx:q["@context"],options:a})),k=D;let X=null;for(const _ of H)if(I(D,_,{vocab:!0},a)==="@type"){X=X||_;const z=q[_],P=Array.isArray(z)?z.length>1?z.slice().sort():z:[z];for(const Q of P){const W=R(k,Q,"@context");i(W)||(D=await m({activeCtx:D,localCtx:W,options:a,propagate:!1}))}}let S={};await g({activeCtx:D,activeProperty:h,expandedActiveProperty:p,element:q,expandedParent:S,options:a,insideList:j,typeKey:X,typeScopedContext:k}),H=Object.keys(S);let x=H.length;if("@value"in S){if("@type"in S&&("@language"in S||"@direction"in S))throw new v('Invalid JSON-LD syntax; an element containing "@value" may not contain both "@type" and either "@language" or "@direction".',"jsonld.SyntaxError",{code:"invalid value object",element:S});let _=x-1;if("@type"in S&&(_-=1),"@index"in S&&(_-=1),"@language"in S&&(_-=1),"@direction"in S&&(_-=1),_!==0)throw new v('Invalid JSON-LD syntax; an element containing "@value" may only have an "@index" property and either "@type" or either or both "@language" or "@direction".',"jsonld.SyntaxError",{code:"invalid value object",element:S});const U=S["@value"]===null?[]:l(S["@value"]),z=e(S,"@type");if(!(E(D,1.1)&&z.includes("@json")&&z.length===1))if(U.length===0)a.eventHandler&&d({event:{type:["JsonLdEvent"],code:"null @value value",level:"warning",message:"Dropping null @value value.",details:{value:S}},options:a}),S=null;else{if(!U.every(P=>O(P)||b(P))&&"@language"in S)throw new v("Invalid JSON-LD syntax; only strings may be language-tagged.","jsonld.SyntaxError",{code:"invalid language-tagged value",element:S});if(!z.every(P=>N(P)&&!(O(P)&&P.indexOf("_:")===0)||b(P)))throw new v('Invalid JSON-LD syntax; an element containing "@value" and "@type" must have an absolute IRI for the value of "@type".',"jsonld.SyntaxError",{code:"invalid typed value",element:S})}}else if("@type"in S&&!r(S["@type"]))S["@type"]=[S["@type"]];else if("@set"in S||"@list"in S){if(x>1&&!(x===2&&"@index"in S))throw new v('Invalid JSON-LD syntax; if an element has the property "@set" or "@list", then it can have at most one other property that is "@index".',"jsonld.SyntaxError",{code:"invalid set or list object",element:S});"@set"in S&&(S=S["@set"],H=Object.keys(S),x=H.length)}else x===1&&"@language"in S&&(a.eventHandler&&d({event:{type:["JsonLdEvent"],code:"object with only @language",level:"warning",message:"Dropping object with only @language.",details:{value:S}},options:a}),S=null);return y(S)&&!a.keepFreeFloatingNodes&&!j&&(h===null||p==="@graph"||(R(D,h,"@container")||[]).includes("@graph"))&&(S=o({value:S,count:x,options:a})),S};function o({value:D,count:h,options:q}){if(h===0||"@value"in D||"@list"in D||h===1&&"@id"in D){if(q.eventHandler){let a,j;h===0?(a="empty object",j="Dropping empty object."):"@value"in D?(a="object with only @value",j="Dropping object with only @value."):"@list"in D?(a="object with only @list",j="Dropping object with only @list."):h===1&&"@id"in D&&(a="object with only @id",j="Dropping object with only @id."),d({event:{type:["JsonLdEvent"],code:a,level:"warning",message:j,details:{value:D}},options:q})}return null}return D}async function g({activeCtx:D,activeProperty:h,expandedActiveProperty:q,element:a,expandedParent:j,options:A={},insideList:k,typeKey:p,typeScopedContext:G}){const H=Object.keys(a).sort(),V=[];let X;const S=a[p]&&I(D,r(a[p])?a[p][0]:a[p],{vocab:!0},{...A,typeExpansion:!0})==="@json";for(const x of H){let _=a[x],U;if(x==="@context")continue;const z=I(D,x,{vocab:!0},A);if(z===null||!(N(z)||u(z))){A.eventHandler&&d({event:{type:["JsonLdEvent"],code:"invalid property",level:"warning",message:"Dropping property that did not expand into an absolute IRI or keyword.",details:{property:x,expandedProperty:z}},options:A});continue}if(u(z)){if(q==="@reverse")throw new v("Invalid JSON-LD syntax; a keyword cannot be used as a @reverse property.","jsonld.SyntaxError",{code:"invalid reverse property map",value:_});if(z in j&&z!=="@included"&&z!=="@type")throw new v("Invalid JSON-LD syntax; colliding keywords detected.","jsonld.SyntaxError",{code:"colliding keywords",keyword:z})}if(z==="@id"){if(!O(_)){if(!A.isFrame)throw new v('Invalid JSON-LD syntax; "@id" value must a string.',"jsonld.SyntaxError",{code:"invalid @id value",value:_});if(y(_)){if(!b(_))throw new v('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',"jsonld.SyntaxError",{code:"invalid @id value",value:_})}else if(r(_)){if(!_.every($=>O($)))throw new v('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',"jsonld.SyntaxError",{code:"invalid @id value",value:_})}else throw new v('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',"jsonld.SyntaxError",{code:"invalid @id value",value:_})}J(j,"@id",l(_).map($=>{if(O($)){const C=I(D,$,{base:!0},A);return A.eventHandler&&(C===null?d($===null?{event:{type:["JsonLdEvent"],code:"null @id value",level:"warning",message:"Null @id found.",details:{id:$}},options:A}:{event:{type:["JsonLdEvent"],code:"reserved @id value",level:"warning",message:"Reserved @id found.",details:{id:$}},options:A}):N(C)||d({event:{type:["JsonLdEvent"],code:"relative @id reference",level:"warning",message:"Relative @id reference found.",details:{id:$,expandedId:C}},options:A})),C}return $}),{propertyIsArray:A.isFrame});continue}if(z==="@type"){y(_)&&(_=Object.fromEntries(Object.entries(_).map(([$,C])=>[I(G,$,{vocab:!0}),l(C).map(Y=>I(G,Y,{base:!0,vocab:!0},{...A,typeExpansion:!0}))]))),s(_,A.isFrame),J(j,"@type",l(_).map($=>{if(O($)){const C=I(G,$,{base:!0,vocab:!0},{...A,typeExpansion:!0});return C!=="@json"&&!N(C)&&A.eventHandler&&d({event:{type:["JsonLdEvent"],code:"relative @type reference",level:"warning",message:"Relative @type reference found.",details:{type:$}},options:A}),C}return $}),{propertyIsArray:!!A.isFrame});continue}if(z==="@included"&&E(D,1.1)){const $=l(await T.expand({activeCtx:D,activeProperty:h,element:_,options:A}));if(!$.every(C=>w(C)))throw new v("Invalid JSON-LD syntax; values of @included must expand to node objects.","jsonld.SyntaxError",{code:"invalid @included value",value:_});J(j,"@included",$,{propertyIsArray:!0});continue}if(z==="@graph"&&!(y(_)||r(_)))throw new v('Invalid JSON-LD syntax; "@graph" value must not be an object or an array.',"jsonld.SyntaxError",{code:"invalid @graph value",value:_});if(z==="@value"){X=_,S&&E(D,1.1)?j["@value"]=_:J(j,"@value",_,{propertyIsArray:A.isFrame});continue}if(z==="@language"){if(_===null)continue;if(!O(_)&&!A.isFrame)throw new v('Invalid JSON-LD syntax; "@language" value must be a string.',"jsonld.SyntaxError",{code:"invalid language-tagged string",value:_});_=l(_).map($=>O($)?$.toLowerCase():$);for(const $ of _)O($)&&!$.match(F)&&A.eventHandler&&d({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:$}},options:A});J(j,"@language",_,{propertyIsArray:A.isFrame});continue}if(z==="@direction"){if(!O(_)&&!A.isFrame)throw new v('Invalid JSON-LD syntax; "@direction" value must be a string.',"jsonld.SyntaxError",{code:"invalid base direction",value:_});_=l(_);for(const $ of _)if(O($)&&$!=="ltr"&&$!=="rtl")throw new v('Invalid JSON-LD syntax; "@direction" must be "ltr" or "rtl".',"jsonld.SyntaxError",{code:"invalid base direction",value:_});J(j,"@direction",_,{propertyIsArray:A.isFrame});continue}if(z==="@index"){if(!O(_))throw new v('Invalid JSON-LD syntax; "@index" value must be a string.',"jsonld.SyntaxError",{code:"invalid @index value",value:_});J(j,"@index",_);continue}if(z==="@reverse"){if(!y(_))throw new v('Invalid JSON-LD syntax; "@reverse" value must be an object.',"jsonld.SyntaxError",{code:"invalid @reverse value",value:_});if(U=await T.expand({activeCtx:D,activeProperty:"@reverse",element:_,options:A}),"@reverse"in U)for(const C in U["@reverse"])J(j,C,U["@reverse"][C],{propertyIsArray:!0});let $=j["@reverse"]||null;for(const C in U){if(C==="@reverse")continue;$===null&&($=j["@reverse"]={}),J($,C,[],{propertyIsArray:!0});const Y=U[C];for(let K=0;K<Y.length;++K){const Z=Y[K];if(t(Z)||n(Z))throw new v('Invalid JSON-LD syntax; "@reverse" value must not be a @value or an @list.',"jsonld.SyntaxError",{code:"invalid reverse property value",value:U});J($,C,Z,{propertyIsArray:!0})}}continue}if(z==="@nest"){V.push(x);continue}let P=D;const Q=R(D,x,"@context");i(Q)||(P=await m({activeCtx:D,localCtx:Q,propagate:!0,overrideProtected:!0,options:A}));const W=R(D,x,"@container")||[];if(W.includes("@language")&&y(_)){const $=R(P,x,"@direction");U=L(P,_,$,A)}else if(W.includes("@index")&&y(_)){const $=W.includes("@graph"),C=R(P,x,"@index")||"@index",Y=C!=="@index"&&I(D,C,{vocab:!0},A);U=await M({activeCtx:P,options:A,activeProperty:x,value:_,asGraph:$,indexKey:C,propertyIndex:Y})}else if(W.includes("@id")&&y(_)){const $=W.includes("@graph");U=await M({activeCtx:P,options:A,activeProperty:x,value:_,asGraph:$,indexKey:"@id"})}else if(W.includes("@type")&&y(_))U=await M({activeCtx:P.revertToPreviousContext(),options:A,activeProperty:x,value:_,asGraph:!1,indexKey:"@type"});else{const $=z==="@list";if($||z==="@set"){let C=h;$&&q==="@graph"&&(C=null),U=await T.expand({activeCtx:P,activeProperty:C,element:_,options:A,insideList:$})}else R(D,x,"@type")==="@json"?U={"@type":"@json","@value":_}:U=await T.expand({activeCtx:P,activeProperty:x,element:_,options:A,insideList:!1})}if(!(U===null&&z!=="@value")){if(z!=="@list"&&!n(U)&&W.includes("@list")&&(U={"@list":l(U)}),W.includes("@graph")&&!W.some($=>$==="@id"||$==="@index")){if(U=l(U),A.isFrame||(U=U.filter($=>{const C=Object.keys($).length;return o({value:$,count:C,options:A})!==null})),U.length===0)continue;U=U.map($=>({"@graph":l($)}))}if(P.mappings.has(x)&&P.mappings.get(x).reverse){const $=j["@reverse"]=j["@reverse"]||{};U=l(U);for(let C=0;C<U.length;++C){const Y=U[C];if(t(Y)||n(Y))throw new v('Invalid JSON-LD syntax; "@reverse" value must not be a @value or an @list.',"jsonld.SyntaxError",{code:"invalid reverse property value",value:U});J($,z,Y,{propertyIsArray:!0})}continue}J(j,z,U,{propertyIsArray:!0})}}if("@value"in j&&!(j["@type"]==="@json"&&E(D,1.1))){if((y(X)||r(X))&&!A.isFrame)throw new v('Invalid JSON-LD syntax; "@value" value must not be an object or an array.',"jsonld.SyntaxError",{code:"invalid value object value",value:X})}for(const x of V){const _=r(a[x])?a[x]:[a[x]];for(const U of _){if(!y(U)||Object.keys(U).some(z=>I(D,z,{vocab:!0},A)==="@value"))throw new v("Invalid JSON-LD syntax; nested value must be a node object.","jsonld.SyntaxError",{code:"invalid @nest value",value:U});await g({activeCtx:D,activeProperty:h,expandedActiveProperty:q,element:U,expandedParent:j,options:A,insideList:k,typeScopedContext:G,typeKey:p})}}}function f({activeCtx:D,activeProperty:h,value:q,options:a}){if(q==null)return null;const j=I(D,h,{vocab:!0},a);if(j==="@id")return I(D,q,{base:!0},a);if(j==="@type")return I(D,q,{vocab:!0,base:!0},{...a,typeExpansion:!0});const A=R(D,h,"@type");if((A==="@id"||j==="@graph")&&O(q)){const p=I(D,q,{base:!0},a);return p===null&&q.match(B)&&a.eventHandler&&d({event:{type:["JsonLdEvent"],code:"reserved @id value",level:"warning",message:"Reserved @id found.",details:{id:h}},options:a}),{"@id":p}}if(A==="@vocab"&&O(q))return{"@id":I(D,q,{vocab:!0,base:!0},a)};if(u(j))return q;const k={};if(A&&!["@id","@vocab","@none"].includes(A))k["@type"]=A;else if(O(q)){const p=R(D,h,"@language");p!==null&&(k["@language"]=p);const G=R(D,h,"@direction");G!==null&&(k["@direction"]=G)}return["boolean","number","string"].includes(typeof q)||(q=q.toString()),k["@value"]=q,k}function L(D,h,q,a){const j=[],A=Object.keys(h).sort();for(const k of A){const p=I(D,k,{vocab:!0},a);let G=h[k];r(G)||(G=[G]);for(const H of G){if(H===null)continue;if(!O(H))throw new v("Invalid JSON-LD syntax; language map values must be strings.","jsonld.SyntaxError",{code:"invalid language map value",languageMap:h});const V={"@value":H};p!=="@none"&&(k.match(F)||a.eventHandler&&d({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:k}},options:a}),V["@language"]=k.toLowerCase()),q&&(V["@direction"]=q),j.push(V)}}return j}async function M({activeCtx:D,options:h,activeProperty:q,value:a,asGraph:j,indexKey:A,propertyIndex:k}){const p=[],G=Object.keys(a).sort(),H=A==="@type";for(let V of G){if(H){const x=R(D,V,"@context");i(x)||(D=await m({activeCtx:D,localCtx:x,propagate:!1,options:h}))}let X=a[V];r(X)||(X=[X]),X=await T.expand({activeCtx:D,activeProperty:q,element:X,options:h,insideList:!1,insideIndex:!0});let S;k?V==="@none"?S="@none":S=f({activeCtx:D,activeProperty:A,value:V,options:h}):S=I(D,V,{vocab:!0},h),A==="@id"?V=I(D,V,{base:!0},h):H&&(V=S);for(let x of X){if(j&&!c(x)&&(x={"@graph":[x]}),A==="@type")S==="@none"||(x["@type"]?x["@type"]=[V].concat(x["@type"]):x["@type"]=[V]);else{if(t(x)&&!["@language","@type","@index"].includes(A))throw new v(`Invalid JSON-LD syntax; Attempt to add illegal key to value object: "${A}".`,"jsonld.SyntaxError",{code:"invalid value object",value:x});k?S!=="@none"&&J(x,k,S,{propertyIsArray:!0,prependValue:!0}):S!=="@none"&&!(A in x)&&(x[A]=V)}p.push(x)}}return p}return He}var Pe,Ot;function ue(){if(Ot)return Pe;Ot=1;const{isKeyword:v}=se(),r=re(),y=ee(),b=te(),O=ne(),i={};return Pe=i,i.createMergedNodeMap=(n,t)=>{t=t||{};const c=t.issuer||new b.IdentifierIssuer("_:b"),w={"@default":{}};return i.createNodeMap(n,w,"@default",c),i.mergeNodeMaps(w)},i.createNodeMap=(n,t,c,w,I,R)=>{if(y.isArray(n)){for(const N of n)i.createNodeMap(N,t,c,w,void 0,R);return}if(!y.isObject(n)){R&&R.push(n);return}if(r.isValue(n)){if("@type"in n){let N=n["@type"];N.indexOf("_:")===0&&(n["@type"]=N=w.getId(N))}R&&R.push(n);return}else if(R&&r.isList(n)){const N=[];i.createNodeMap(n["@list"],t,c,w,I,N),R.push({"@list":N});return}if("@type"in n){const N=n["@type"];for(const F of N)F.indexOf("_:")===0&&w.getId(F)}y.isUndefined(I)&&(I=r.isBlankNode(n)?w.getId(n["@id"]):n["@id"]),R&&R.push({"@id":I});const u=t[c],m=u[I]=u[I]||{};m["@id"]=I;const E=Object.keys(n).sort();for(let N of E){if(N==="@id")continue;if(N==="@reverse"){const B={"@id":I},J=n["@reverse"];for(const l in J){const e=J[l];for(const s of e){let d=s["@id"];r.isBlankNode(s)&&(d=w.getId(d)),i.createNodeMap(s,t,c,w,d),b.addValue(u[d],l,B,{propertyIsArray:!0,allowDuplicate:!1})}}continue}if(N==="@graph"){I in t||(t[I]={}),i.createNodeMap(n[N],t,I,w);continue}if(N==="@included"){i.createNodeMap(n[N],t,c,w);continue}if(N!=="@type"&&v(N)){if(N==="@index"&&N in m&&(n[N]!==m[N]||n[N]["@id"]!==m[N]["@id"]))throw new O("Invalid JSON-LD syntax; conflicting @index property detected.","jsonld.SyntaxError",{code:"conflicting indexes",subject:m});m[N]=n[N];continue}const F=n[N];if(N.indexOf("_:")===0&&(N=w.getId(N)),F.length===0){b.addValue(m,N,[],{propertyIsArray:!0});continue}for(let B of F)if(N==="@type"&&(B=B.indexOf("_:")===0?w.getId(B):B),r.isSubject(B)||r.isSubjectReference(B)){if("@id"in B&&!B["@id"])continue;const J=r.isBlankNode(B)?w.getId(B["@id"]):B["@id"];b.addValue(m,N,{"@id":J},{propertyIsArray:!0,allowDuplicate:!1}),i.createNodeMap(B,t,c,w,J)}else if(r.isValue(B))b.addValue(m,N,B,{propertyIsArray:!0,allowDuplicate:!1});else if(r.isList(B)){const J=[];i.createNodeMap(B["@list"],t,c,w,I,J),B={"@list":J},b.addValue(m,N,B,{propertyIsArray:!0,allowDuplicate:!1})}else i.createNodeMap(B,t,c,w,I),b.addValue(m,N,B,{propertyIsArray:!0,allowDuplicate:!1})}},i.mergeNodeMapGraphs=n=>{const t={};for(const c of Object.keys(n).sort())for(const w of Object.keys(n[c]).sort()){const I=n[c][w];w in t||(t[w]={"@id":w});const R=t[w];for(const u of Object.keys(I).sort())if(v(u)&&u!=="@type")R[u]=b.clone(I[u]);else for(const m of I[u])b.addValue(R,u,b.clone(m),{propertyIsArray:!0,allowDuplicate:!1})}return t},i.mergeNodeMaps=n=>{const t=n["@default"],c=Object.keys(n).sort();for(const w of c){if(w==="@default")continue;const I=n[w];let R=t[w];R?"@graph"in R||(R["@graph"]=[]):t[w]=R={"@id":w,"@graph":[]};const u=R["@graph"];for(const m of Object.keys(I).sort()){const E=I[m];r.isSubjectReference(E)||u.push(E)}}return t},Pe}var Ue,Lt;function on(){if(Lt)return Ue;Lt=1;const{isSubjectReference:v}=re(),{createMergedNodeMap:r}=ue(),y={};return Ue=y,y.flatten=b=>{const O=r(b),i=[],n=Object.keys(O).sort();for(let t=0;t<n.length;++t){const c=O[n[t]];v(c)||i.push(c)}return i},Ue}var Be,At;function ln(){if(At)return Be;At=1;const v=ne(),r=re(),y=ee(),{REGEX_BCP47:b,addValue:O}=te(),{handleEvent:i}=oe(),{RDF_LIST:n,RDF_FIRST:t,RDF_REST:c,RDF_NIL:w,RDF_TYPE:I,RDF_JSON_LITERAL:R,XSD_BOOLEAN:u,XSD_DOUBLE:m,XSD_INTEGER:E,XSD_STRING:N}=Ze(),F={};Be=F,F.fromRDF=async(l,e)=>{const{useRdfType:s=!1,useNativeTypes:d=!1,rdfDirection:T=null}=e,o={},g={"@default":o},f={};if(T){if(T==="compound-literal")throw new v("Unsupported rdfDirection value.","jsonld.InvalidRdfDirection",{value:T});if(T!=="i18n-datatype")throw new v("Unknown rdfDirection value.","jsonld.InvalidRdfDirection",{value:T})}for(const D of l){const h=D.graph.termType==="DefaultGraph"?"@default":D.graph.value;h in g||(g[h]={}),h!=="@default"&&!(h in o)&&(o[h]={"@id":h});const q=g[h],a=J(D.subject),j=D.predicate.value,A=D.object;a in q||(q[a]={"@id":a});const k=q[a],p=J(A),G=!!p;if(G&&!(p in q)&&(q[p]={"@id":p}),j===I&&!s&&G){O(k,"@type",p,{propertyIsArray:!0});continue}const H=B(A,d,T,e);if(O(k,j,H,{propertyIsArray:!0}),G)if(p===w){const V=q[p];"usages"in V||(V.usages=[]),V.usages.push({node:k,property:j,value:H})}else p in f?f[p]=!1:f[p]={node:k,property:j,value:H}}for(const D in g){const h=g[D];if(!(w in h))continue;const q=h[w];if(q.usages){for(let a of q.usages){let j=a.node,A=a.property,k=a.value;const p=[],G=[];let H=Object.keys(j).length;for(;A===c&&y.isObject(f[j["@id"]])&&y.isArray(j[t])&&j[t].length===1&&y.isArray(j[c])&&j[c].length===1&&(H===3||H===4&&y.isArray(j["@type"])&&j["@type"].length===1&&j["@type"][0]===n)&&(p.push(j[t][0]),G.push(j["@id"]),a=f[j["@id"]],j=a.node,A=a.property,k=a.value,H=Object.keys(j).length,!!r.isBlankNode(j)););delete k["@id"],k["@list"]=p.reverse();for(const V of G)delete h[V]}delete q.usages}}const L=[],M=Object.keys(o).sort();for(const D of M){const h=o[D];if(D in g){const q=h["@graph"]=[],a=g[D],j=Object.keys(a).sort();for(const A of j){const k=a[A];r.isSubjectReference(k)||q.push(k)}}r.isSubjectReference(h)||L.push(h)}return L};function B(l,e,s,d){const T=J(l);if(T)return{"@id":T};const o={"@value":l.value};if(l.language)l.language.match(b)||d.eventHandler&&i({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:l.language}},options:d}),o["@language"]=l.language;else{let g=l.datatype.value;if(g||(g=N),g===R){g="@json";try{o["@value"]=JSON.parse(o["@value"])}catch(f){throw new v("JSON literal could not be parsed.","jsonld.InvalidJsonLiteral",{code:"invalid JSON literal",value:o["@value"],cause:f})}}if(e)if(g===u)o["@value"]==="true"||o["@value"]==="1"?o["@value"]=!0:o["@value"]==="false"||o["@value"]==="0"?o["@value"]=!1:o["@type"]=g;else if(g===E)if(y.isNumeric(o["@value"])){const f=parseInt(o["@value"],10);f.toFixed(0)===o["@value"]&&(o["@value"]=f)}else o["@type"]=g;else g===m&&y.isNumeric(o["@value"])?o["@value"]=parseFloat(o["@value"]):o["@type"]=g;else if(s==="i18n-datatype"&&g.startsWith("https://www.w3.org/ns/i18n#")){const[,f,L]=g.split(/[#_]/);f.length>0&&(o["@language"]=f,f.match(b)||d.eventHandler&&i({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:f}},options:d})),o["@direction"]=L}else g!==N&&(o["@type"]=g)}return o}function J(l){return l.termType==="NamedNode"?l.value:l.termType==="BlankNode"?"_:"+l.value:null}return Be}var Ve,Tt;function cn(){return Tt||(Tt=1,Ve=function v(r){if(typeof r=="number"&&isNaN(r))throw new Error("NaN is not allowed");if(typeof r=="number"&&!isFinite(r))throw new Error("Infinity is not allowed");return r===null||typeof r!="object"?JSON.stringify(r):r.toJSON instanceof Function?v(r.toJSON()):Array.isArray(r)?`[${r.reduce((O,i,n)=>`${O}${n===0?"":","}${v(i===void 0||typeof i=="symbol"?null:i)}`,"")}]`:`{${Object.keys(r).sort().reduce((b,O)=>{if(r[O]===void 0||typeof r[O]=="symbol")return b;const i=b.length===0?"":",";return`${b}${i}${v(O)}:${v(r[O])}`},"")}}`}),Ve}var Ge,kt;function un(){if(kt)return Ge;kt=1;const{createNodeMap:v}=ue(),{isKeyword:r}=se(),y=re(),b=cn(),O=ne(),i=ee(),n=te(),{handleEvent:t}=oe(),{RDF_FIRST:c,RDF_REST:w,RDF_NIL:I,RDF_TYPE:R,RDF_JSON_LITERAL:u,RDF_LANGSTRING:m,XSD_BOOLEAN:E,XSD_DOUBLE:N,XSD_INTEGER:F,XSD_STRING:B}=Ze(),{isAbsolute:J}=ie(),l={};Ge=l,l.toRDF=(o,g)=>{const f=new n.IdentifierIssuer("_:b"),L={"@default":{}};v(o,L,"@default",f);const M=[],D=Object.keys(L).sort();for(const h of D){let q;if(h==="@default")q={termType:"DefaultGraph",value:""};else if(J(h))q=T(h);else{g.eventHandler&&t({event:{type:["JsonLdEvent"],code:"relative graph reference",level:"warning",message:"Relative graph reference found.",details:{graph:h}},options:g});continue}e(M,L[h],q,f,g)}return M};function e(o,g,f,L,M){const D=Object.keys(g).sort();for(const h of D){const q=g[h],a=Object.keys(q).sort();for(let j of a){const A=q[j];if(j==="@type")j=R;else if(r(j))continue;for(const k of A){const p=T(h);if(!J(h)){M.eventHandler&&t({event:{type:["JsonLdEvent"],code:"relative subject reference",level:"warning",message:"Relative subject reference found.",details:{subject:h}},options:M});continue}const G=T(j);if(!J(j)){M.eventHandler&&t({event:{type:["JsonLdEvent"],code:"relative predicate reference",level:"warning",message:"Relative predicate reference found.",details:{predicate:j}},options:M});continue}if(G.termType==="BlankNode"&&!M.produceGeneralizedRdf){M.eventHandler&&t({event:{type:["JsonLdEvent"],code:"blank node predicate",level:"warning",message:"Dropping blank node predicate.",details:{property:L.getOldIds().find(V=>L.getId(V)===j)}},options:M});continue}const H=d(k,L,o,f,M.rdfDirection,M);H&&o.push({subject:p,predicate:G,object:H,graph:f})}}}}function s(o,g,f,L,M,D){const h={termType:"NamedNode",value:c},q={termType:"NamedNode",value:w},a={termType:"NamedNode",value:I},j=o.pop(),A=j?{termType:"BlankNode",value:g.getId().slice(2)}:a;let k=A;for(const p of o){const G=d(p,g,f,L,M,D),H={termType:"BlankNode",value:g.getId().slice(2)};f.push({subject:k,predicate:h,object:G,graph:L}),f.push({subject:k,predicate:q,object:H,graph:L}),k=H}if(j){const p=d(j,g,f,L,M,D);f.push({subject:k,predicate:h,object:p,graph:L}),f.push({subject:k,predicate:q,object:a,graph:L})}return A}function d(o,g,f,L,M,D){let h;if(y.isValue(o)){h={termType:"Literal",value:void 0,datatype:{termType:"NamedNode"}};let q=o["@value"];const a=o["@type"]||null;if(a==="@json")h.value=b(q),h.datatype.value=u;else if(i.isBoolean(q))h.value=q.toString(),h.datatype.value=a||E;else if(i.isDouble(q)||a===N)i.isDouble(q)||(q=parseFloat(q)),h.value=q.toExponential(15).replace(/(\d)0*e\+?/,"$1E"),h.datatype.value=a||N;else if(i.isNumber(q))h.value=q.toFixed(0),h.datatype.value=a||F;else if("@direction"in o&&M==="i18n-datatype"){const j=(o["@language"]||"").toLowerCase(),A=o["@direction"],k=`https://www.w3.org/ns/i18n#${j}_${A}`;h.datatype.value=k,h.value=q}else{if("@direction"in o&&M==="compound-literal")throw new O("Unsupported rdfDirection value.","jsonld.InvalidRdfDirection",{value:M});if("@direction"in o&&M)throw new O("Unknown rdfDirection value.","jsonld.InvalidRdfDirection",{value:M});"@language"in o?("@direction"in o&&!M&&D.eventHandler&&t({event:{type:["JsonLdEvent"],code:"rdfDirection not set",level:"warning",message:"rdfDirection not set for @direction.",details:{object:h.value}},options:D}),h.value=q,h.datatype.value=a||m,h.language=o["@language"]):("@direction"in o&&!M&&D.eventHandler&&t({event:{type:["JsonLdEvent"],code:"rdfDirection not set",level:"warning",message:"rdfDirection not set for @direction.",details:{object:h.value}},options:D}),h.value=q,h.datatype.value=a||B)}}else if(y.isList(o)){const q=s(o["@list"],g,f,L,M,D);h={termType:q.termType,value:q.value}}else{const q=i.isObject(o)?o["@id"]:o;h=T(q)}return h.termType==="NamedNode"&&!J(h.value)?(D.eventHandler&&t({event:{type:["JsonLdEvent"],code:"relative object reference",level:"warning",message:"Relative object reference found.",details:{object:h.value}},options:D}),null):h}function T(o){return o.startsWith("_:")?{termType:"BlankNode",value:o.slice(2)}:{termType:"NamedNode",value:o}}return Ge}var $e,Mt;function dn(){if(Mt)return $e;Mt=1;const{isKeyword:v}=se(),r=re(),y=ee(),b=te(),O=ie(),i=ne(),{createNodeMap:n,mergeNodeMapGraphs:t}=ue(),c={};$e=c,c.frameMergedOrDefault=(e,s,d)=>{const T={options:d,embedded:!1,graph:"@default",graphMap:{"@default":{}},subjectStack:[],link:{},bnodeMap:{}},o=new b.IdentifierIssuer("_:b");n(e,T.graphMap,"@default",o),d.merged&&(T.graphMap["@merged"]=t(T.graphMap),T.graph="@merged"),T.subjects=T.graphMap[T.graph];const g=[];c.frame(T,Object.keys(T.subjects).sort(),s,g),d.pruneBlankNodeIdentifiers&&(d.bnodesToClear=Object.keys(T.bnodeMap).filter(f=>T.bnodeMap[f].length===1));return d.link={},F(g,d)},c.frame=(e,s,d,T,o=null)=>{u(d),d=d[0];const g=e.options,f={embed:R(d,g,"embed"),explicit:R(d,g,"explicit"),requireAll:R(d,g,"requireAll")};e.link.hasOwnProperty(e.graph)||(e.link[e.graph]={});const L=e.link[e.graph],M=m(e,s,d,f),D=Object.keys(M).sort();for(const h of D){const q=M[h];if(o===null?e.uniqueEmbeds={[e.graph]:{}}:e.uniqueEmbeds[e.graph]=e.uniqueEmbeds[e.graph]||{},f.embed==="@link"&&h in L){B(T,o,L[h]);continue}const a={"@id":h};if(h.indexOf("_:")===0&&b.addValue(e.bnodeMap,h,a,{propertyIsArray:!0}),L[h]=a,(f.embed==="@first"||f.embed==="@last")&&e.is11)throw new i("Invalid JSON-LD syntax; invalid value of @embed.","jsonld.SyntaxError",{code:"invalid @embed value",frame:d});if(!(!e.embedded&&e.uniqueEmbeds[e.graph].hasOwnProperty(h))){if(e.embedded&&(f.embed==="@never"||I(q,e.graph,e.subjectStack))){B(T,o,a);continue}if(e.embedded&&(f.embed=="@first"||f.embed=="@once")&&e.uniqueEmbeds[e.graph].hasOwnProperty(h)){B(T,o,a);continue}if(f.embed==="@last"&&h in e.uniqueEmbeds[e.graph]&&N(e,h),e.uniqueEmbeds[e.graph][h]={parent:T,property:o},e.subjectStack.push({subject:q,graph:e.graph}),h in e.graphMap){let j=!1,A=null;"@graph"in d?(A=d["@graph"][0],j=!(h==="@merged"||h==="@default"),y.isObject(A)||(A={})):(j=e.graph!=="@merged",A={}),j&&c.frame({...e,graph:h,embedded:!1},Object.keys(e.graphMap[h]).sort(),[A],a,"@graph")}"@included"in d&&c.frame({...e,embedded:!1},s,d["@included"],a,"@included");for(const j of Object.keys(q).sort()){if(v(j)){if(a[j]=b.clone(q[j]),j==="@type")for(const A of q["@type"])A.indexOf("_:")===0&&b.addValue(e.bnodeMap,A,a,{propertyIsArray:!0});continue}if(!(f.explicit&&!(j in d)))for(const A of q[j]){const k=j in d?d[j]:w(f);if(r.isList(A)){const p=d[j]&&d[j][0]&&d[j][0]["@list"]?d[j][0]["@list"]:w(f),G={"@list":[]};B(a,j,G);const H=A["@list"];for(const V of H)r.isSubjectReference(V)?c.frame({...e,embedded:!0},[V["@id"]],p,G,"@list"):B(G,"@list",b.clone(V))}else r.isSubjectReference(A)?c.frame({...e,embedded:!0},[A["@id"]],k,a,j):l(k[0],A)&&B(a,j,b.clone(A))}}for(const j of Object.keys(d).sort()){if(j==="@type"){if(!y.isObject(d[j][0])||!("@default"in d[j][0]))continue}else if(v(j))continue;const A=d[j][0]||{};if(!R(A,g,"omitDefault")&&!(j in a)){let p="@null";"@default"in A&&(p=b.clone(A["@default"])),y.isArray(p)||(p=[p]),a[j]=[{"@preserve":p}]}}for(const j of Object.keys(d["@reverse"]||{}).sort()){const A=d["@reverse"][j];for(const k of Object.keys(e.subjects))b.getValues(e.subjects[k],j).some(G=>G["@id"]===h)&&(a["@reverse"]=a["@reverse"]||{},b.addValue(a["@reverse"],j,[],{propertyIsArray:!0}),c.frame({...e,embedded:!0},[k],A,a["@reverse"][j],o))}B(T,o,a),e.subjectStack.pop()}}},c.cleanupNull=(e,s)=>{if(y.isArray(e))return e.map(T=>c.cleanupNull(T,s)).filter(T=>T);if(e==="@null")return null;if(y.isObject(e)){if("@id"in e){const d=e["@id"];if(s.link.hasOwnProperty(d)){const T=s.link[d].indexOf(e);if(T!==-1)return s.link[d][T];s.link[d].push(e)}else s.link[d]=[e]}for(const d in e)e[d]=c.cleanupNull(e[d],s)}return e};function w(e){const s={};for(const d in e)e[d]!==void 0&&(s["@"+d]=[e[d]]);return[s]}function I(e,s,d){for(let T=d.length-1;T>=0;--T){const o=d[T];if(o.graph===s&&o.subject["@id"]===e["@id"])return!0}return!1}function R(e,s,d){const T="@"+d;let o=T in e?e[T][0]:s[d];if(d==="embed"){if(o===!0)o="@once";else if(o===!1)o="@never";else if(o!=="@always"&&o!=="@never"&&o!=="@link"&&o!=="@first"&&o!=="@last"&&o!=="@once")throw new i("Invalid JSON-LD syntax; invalid value of @embed.","jsonld.SyntaxError",{code:"invalid @embed value",frame:e})}return o}function u(e){if(!y.isArray(e)||e.length!==1||!y.isObject(e[0]))throw new i("Invalid JSON-LD syntax; a JSON-LD frame must be a single object.","jsonld.SyntaxError",{frame:e});if("@id"in e[0]){for(const s of b.asArray(e[0]["@id"]))if(!(y.isObject(s)||O.isAbsolute(s))||y.isString(s)&&s.indexOf("_:")===0)throw new i("Invalid JSON-LD syntax; invalid @id in frame.","jsonld.SyntaxError",{code:"invalid frame",frame:e})}if("@type"in e[0]){for(const s of b.asArray(e[0]["@type"]))if(!(y.isObject(s)||O.isAbsolute(s)||s==="@json")||y.isString(s)&&s.indexOf("_:")===0)throw new i("Invalid JSON-LD syntax; invalid @type in frame.","jsonld.SyntaxError",{code:"invalid frame",frame:e})}}function m(e,s,d,T){const o={};for(const g of s){const f=e.graphMap[e.graph][g];E(e,f,d,T)&&(o[g]=f)}return o}function E(e,s,d,T){let o=!0,g=!1;for(const f in d){let L=!1;const M=b.getValues(s,f),D=b.getValues(d,f).length===0;if(f==="@id"){if(y.isEmptyObject(d["@id"][0]||{})?L=!0:d["@id"].length>=0&&(L=d["@id"].includes(M[0])),!T.requireAll)return L}else if(f==="@type"){if(o=!1,D){if(M.length>0)return!1;L=!0}else if(d["@type"].length===1&&y.isEmptyObject(d["@type"][0]))L=M.length>0;else for(const h of d["@type"])y.isObject(h)&&"@default"in h?L=!0:L=L||M.some(q=>q===h);if(!T.requireAll)return L}else{if(v(f))continue;{const h=b.getValues(d,f)[0];let q=!1;if(h&&(u([h]),q="@default"in h),o=!1,M.length===0&&q)continue;if(M.length>0&&D)return!1;if(h===void 0){if(M.length>0)return!1;L=!0}else if(r.isList(h)){const a=h["@list"][0];if(r.isList(M[0])){const j=M[0]["@list"];r.isValue(a)?L=j.some(A=>l(a,A)):(r.isSubject(a)||r.isSubjectReference(a))&&(L=j.some(A=>J(e,a,A,T)))}}else r.isValue(h)?L=M.some(a=>l(h,a)):r.isSubjectReference(h)?L=M.some(a=>J(e,h,a,T)):y.isObject(h)?L=M.length>0:L=!1}}if(!L&&T.requireAll)return!1;g=g||L}return o||g}function N(e,s){const d=e.uniqueEmbeds[e.graph],T=d[s],o=T.parent,g=T.property,f={"@id":s};if(y.isArray(o)){for(let M=0;M<o.length;++M)if(b.compareValues(o[M],f)){o[M]=f;break}}else{const M=y.isArray(o[g]);b.removeValue(o,g,f,{propertyIsArray:M}),b.addValue(o,g,f,{propertyIsArray:M})}const L=M=>{const D=Object.keys(d);for(const h of D)h in d&&y.isObject(d[h].parent)&&d[h].parent["@id"]===M&&(delete d[h],L(h))};L(s)}function F(e,s){if(y.isArray(e))return e.map(d=>F(d,s));if(y.isObject(e)){if("@preserve"in e)return e["@preserve"][0];if(r.isValue(e))return e;if(r.isList(e))return e["@list"]=F(e["@list"],s),e;if("@id"in e){const d=e["@id"];if(s.link.hasOwnProperty(d)){const T=s.link[d].indexOf(e);if(T!==-1)return s.link[d][T];s.link[d].push(e)}else s.link[d]=[e]}for(const d in e){if(d==="@id"&&s.bnodesToClear.includes(e[d])){delete e["@id"];continue}e[d]=F(e[d],s)}}return e}function B(e,s,d){y.isObject(e)?b.addValue(e,s,d,{propertyIsArray:!0}):e.push(d)}function J(e,s,d,T){if(!("@id"in d))return!1;const o=e.subjects[d["@id"]];return o&&E(e,o,s,T)}function l(e,s){const d=s["@value"],T=s["@type"],o=s["@language"],g=e["@value"]?y.isArray(e["@value"])?e["@value"]:[e["@value"]]:[],f=e["@type"]?y.isArray(e["@type"])?e["@type"]:[e["@type"]]:[],L=e["@language"]?y.isArray(e["@language"])?e["@language"]:[e["@language"]]:[];return g.length===0&&f.length===0&&L.length===0?!0:!(!(g.includes(d)||y.isEmptyObject(g[0]))||!(!T&&f.length===0||f.includes(T)||T&&y.isEmptyObject(f[0]))||!(!o&&L.length===0||L.includes(o)||o&&y.isEmptyObject(L[0])))}return $e}var ze,Ft;function fn(){if(Ft)return ze;Ft=1;const v=ne(),{isArray:r,isObject:y,isString:b,isUndefined:O}=ee(),{isList:i,isValue:n,isGraph:t,isSimpleGraph:c,isSubjectReference:w}=re(),{expandIri:I,getContextValue:R,isKeyword:u,process:m,processingMode:E}=se(),{removeBase:N,prependBase:F}=ie(),{REGEX_KEYWORD:B,addValue:J,asArray:l,compareShortestLeast:e}=te(),s={};ze=s,s.compact=async({activeCtx:o,activeProperty:g=null,element:f,options:L={}})=>{if(r(f)){let D=[];for(let h=0;h<f.length;++h){const q=await s.compact({activeCtx:o,activeProperty:g,element:f[h],options:L});q!==null&&D.push(q)}return L.compactArrays&&D.length===1&&(R(o,g,"@container")||[]).length===0&&(D=D[0]),D}const M=R(o,g,"@context");if(O(M)||(o=await m({activeCtx:o,localCtx:M,propagate:!0,overrideProtected:!0,options:L})),y(f)){if(L.link&&"@id"in f&&L.link.hasOwnProperty(f["@id"])){const p=L.link[f["@id"]];for(let G=0;G<p.length;++G)if(p[G].expanded===f)return p[G].compacted}if(n(f)||w(f)){const p=s.compactValue({activeCtx:o,activeProperty:g,value:f,options:L});return L.link&&w(f)&&(L.link.hasOwnProperty(f["@id"])||(L.link[f["@id"]]=[]),L.link[f["@id"]].push({expanded:f,compacted:p})),p}if(i(f)&&(R(o,g,"@container")||[]).includes("@list"))return s.compact({activeCtx:o,activeProperty:g,element:f["@list"],options:L});const D=g==="@reverse",h={},q=o;!n(f)&&!w(f)&&(o=o.revertToPreviousContext());const a=R(q,g,"@context");O(a)||(o=await m({activeCtx:o,localCtx:a,propagate:!0,overrideProtected:!0,options:L})),L.link&&"@id"in f&&(L.link.hasOwnProperty(f["@id"])||(L.link[f["@id"]]=[]),L.link[f["@id"]].push({expanded:f,compacted:h}));let j=f["@type"]||[];j.length>1&&(j=Array.from(j).sort());const A=o;for(const p of j){const G=s.compactIri({activeCtx:A,iri:p,relativeTo:{vocab:!0}}),H=R(q,G,"@context");O(H)||(o=await m({activeCtx:o,localCtx:H,options:L,propagate:!1}))}const k=Object.keys(f).sort();for(const p of k){const G=f[p];if(p==="@id"){let H=l(G).map(X=>s.compactIri({activeCtx:o,iri:X,relativeTo:{vocab:!1},base:L.base}));H.length===1&&(H=H[0]);const V=s.compactIri({activeCtx:o,iri:"@id",relativeTo:{vocab:!0}});h[V]=H;continue}if(p==="@type"){let H=l(G).map(_=>s.compactIri({activeCtx:q,iri:_,relativeTo:{vocab:!0}}));H.length===1&&(H=H[0]);const V=s.compactIri({activeCtx:o,iri:"@type",relativeTo:{vocab:!0}}),x=(R(o,V,"@container")||[]).includes("@set")&&E(o,1.1)||r(H)&&G.length===0;J(h,V,H,{propertyIsArray:x});continue}if(p==="@reverse"){const H=await s.compact({activeCtx:o,activeProperty:"@reverse",element:G,options:L});for(const V in H)if(o.mappings.has(V)&&o.mappings.get(V).reverse){const X=H[V],x=(R(o,V,"@container")||[]).includes("@set")||!L.compactArrays;J(h,V,X,{propertyIsArray:x}),delete H[V]}if(Object.keys(H).length>0){const V=s.compactIri({activeCtx:o,iri:p,relativeTo:{vocab:!0}});J(h,V,H)}continue}if(p==="@preserve"){const H=await s.compact({activeCtx:o,activeProperty:g,element:G,options:L});r(H)&&H.length===0||J(h,p,H);continue}if(p==="@index"){if((R(o,g,"@container")||[]).includes("@index"))continue;const V=s.compactIri({activeCtx:o,iri:p,relativeTo:{vocab:!0}});J(h,V,G);continue}if(p!=="@graph"&&p!=="@list"&&p!=="@included"&&u(p)){const H=s.compactIri({activeCtx:o,iri:p,relativeTo:{vocab:!0}});J(h,H,G);continue}if(!r(G))throw new v("JSON-LD expansion error; expanded value must be an array.","jsonld.SyntaxError");if(G.length===0){const H=s.compactIri({activeCtx:o,iri:p,value:G,relativeTo:{vocab:!0},reverse:D}),V=o.mappings.has(H)?o.mappings.get(H)["@nest"]:null;let X=h;V&&(T(o,V,L),y(h[V])||(h[V]={}),X=h[V]),J(X,H,G,{propertyIsArray:!0})}for(const H of G){const V=s.compactIri({activeCtx:o,iri:p,value:H,relativeTo:{vocab:!0},reverse:D}),X=o.mappings.has(V)?o.mappings.get(V)["@nest"]:null;let S=h;X&&(T(o,X,L),y(h[X])||(h[X]={}),S=h[X]);const x=R(o,V,"@container")||[],_=t(H),U=i(H);let z;U?z=H["@list"]:_&&(z=H["@graph"]);let P=await s.compact({activeCtx:o,activeProperty:V,element:U||_?z:H,options:L});if(U)if(r(P)||(P=[P]),!x.includes("@list"))P={[s.compactIri({activeCtx:o,iri:"@list",relativeTo:{vocab:!0}})]:P},"@index"in H&&(P[s.compactIri({activeCtx:o,iri:"@index",relativeTo:{vocab:!0}})]=H["@index"]);else{J(S,V,P,{valueIsArray:!0,allowDuplicate:!0});continue}if(_)if(x.includes("@graph")&&(x.includes("@id")||x.includes("@index")&&c(H))){let Q;S.hasOwnProperty(V)?Q=S[V]:S[V]=Q={};const W=(x.includes("@id")?H["@id"]:H["@index"])||s.compactIri({activeCtx:o,iri:"@none",relativeTo:{vocab:!0}});J(Q,W,P,{propertyIsArray:!L.compactArrays||x.includes("@set")})}else x.includes("@graph")&&c(H)?(r(P)&&P.length>1&&(P={"@included":P}),J(S,V,P,{propertyIsArray:!L.compactArrays||x.includes("@set")})):(r(P)&&P.length===1&&L.compactArrays&&(P=P[0]),P={[s.compactIri({activeCtx:o,iri:"@graph",relativeTo:{vocab:!0}})]:P},"@id"in H&&(P[s.compactIri({activeCtx:o,iri:"@id",relativeTo:{vocab:!0}})]=H["@id"]),"@index"in H&&(P[s.compactIri({activeCtx:o,iri:"@index",relativeTo:{vocab:!0}})]=H["@index"]),J(S,V,P,{propertyIsArray:!L.compactArrays||x.includes("@set")}));else if(x.includes("@language")||x.includes("@index")||x.includes("@id")||x.includes("@type")){let Q;S.hasOwnProperty(V)?Q=S[V]:S[V]=Q={};let W;if(x.includes("@language"))n(P)&&(P=P["@value"]),W=H["@language"];else if(x.includes("@index")){const $=R(o,V,"@index")||"@index",C=s.compactIri({activeCtx:o,iri:$,relativeTo:{vocab:!0}});if($==="@index")W=H["@index"],delete P[C];else{let Y;if([W,...Y]=l(P[$]||[]),!b(W))W=null;else switch(Y.length){case 0:delete P[$];break;case 1:P[$]=Y[0];break;default:P[$]=Y;break}}}else if(x.includes("@id")){const $=s.compactIri({activeCtx:o,iri:"@id",relativeTo:{vocab:!0}});W=P[$],delete P[$]}else if(x.includes("@type")){const $=s.compactIri({activeCtx:o,iri:"@type",relativeTo:{vocab:!0}});let C;switch([W,...C]=l(P[$]||[]),C.length){case 0:delete P[$];break;case 1:P[$]=C[0];break;default:P[$]=C;break}Object.keys(P).length===1&&"@id"in H&&(P=await s.compact({activeCtx:o,activeProperty:V,element:{"@id":H["@id"]},options:L}))}W||(W=s.compactIri({activeCtx:o,iri:"@none",relativeTo:{vocab:!0}})),J(Q,W,P,{propertyIsArray:x.includes("@set")})}else{const Q=!L.compactArrays||x.includes("@set")||x.includes("@list")||r(P)&&P.length===0||p==="@list"||p==="@graph";J(S,V,P,{propertyIsArray:Q})}}}return h}return f},s.compactIri=({activeCtx:o,iri:g,value:f=null,relativeTo:L={vocab:!1},reverse:M=!1,base:D=null})=>{if(g===null)return g;o.isPropertyTermScoped&&o.previousContext&&(o=o.previousContext);const h=o.getInverse();if(u(g)&&g in h&&"@none"in h[g]&&"@type"in h[g]["@none"]&&"@none"in h[g]["@none"]["@type"])return h[g]["@none"]["@type"]["@none"];if(L.vocab&&g in h){const k=o["@language"]||"@none",p=[];y(f)&&"@index"in f&&!("@graph"in f)&&p.push("@index","@index@set"),y(f)&&"@preserve"in f&&(f=f["@preserve"][0]),t(f)?("@index"in f&&p.push("@graph@index","@graph@index@set","@index","@index@set"),"@id"in f&&p.push("@graph@id","@graph@id@set"),p.push("@graph","@graph@set","@set"),"@index"in f||p.push("@graph@index","@graph@index@set","@index","@index@set"),"@id"in f||p.push("@graph@id","@graph@id@set")):y(f)&&!n(f)&&p.push("@id","@id@set","@type","@set@type");let G="@language",H="@null";if(M)G="@type",H="@reverse",p.push("@set");else if(i(f)){"@index"in f||p.push("@list");const X=f["@list"];if(X.length===0)G="@any",H="@none";else{let S=X.length===0?k:null,x=null;for(let _=0;_<X.length;++_){const U=X[_];let z="@none",P="@none";if(n(U))if("@direction"in U){const Q=(U["@language"]||"").toLowerCase(),W=U["@direction"];z=`${Q}_${W}`}else"@language"in U?z=U["@language"].toLowerCase():"@type"in U?P=U["@type"]:z="@null";else P="@id";if(S===null?S=z:z!==S&&n(U)&&(S="@none"),x===null?x=P:P!==x&&(x="@none"),S==="@none"&&x==="@none")break}S=S||"@none",x=x||"@none",x!=="@none"?(G="@type",H=x):H=S}}else{if(n(f))if("@language"in f&&!("@index"in f)){p.push("@language","@language@set"),H=f["@language"];const X=f["@direction"];X&&(H=`${H}_${X}`)}else"@direction"in f&&!("@index"in f)?H=`_${f["@direction"]}`:"@type"in f&&(G="@type",H=f["@type"]);else G="@type",H="@id";p.push("@set")}p.push("@none"),y(f)&&!("@index"in f)&&p.push("@index","@index@set"),n(f)&&Object.keys(f).length===1&&p.push("@language","@language@set");const V=d(o,g,f,p,G,H);if(V!==null)return V}if(L.vocab&&"@vocab"in o){const k=o["@vocab"];if(g.indexOf(k)===0&&g!==k){const p=g.substr(k.length);if(!o.mappings.has(p))return p}}let q=null;const a=[];let j=o.fastCurieMap;const A=g.length-1;for(let k=0;k<A&&g[k]in j;++k)j=j[g[k]],""in j&&a.push(j[""][0]);for(let k=a.length-1;k>=0;--k){const p=a[k],G=p.terms;for(const H of G){const V=H+":"+g.substr(p.iri.length);o.mappings.get(H)._prefix&&(!o.mappings.has(V)||f===null&&o.mappings.get(V)["@id"]===g)&&(q===null||e(V,q)<0)&&(q=V)}}if(q!==null)return q;for(const[k,p]of o.mappings)if(p&&p._prefix&&g.startsWith(k+":"))throw new v(`Absolute IRI "${g}" confused with prefix "${k}".`,"jsonld.SyntaxError",{code:"IRI confused with prefix",context:o});if(!L.vocab)if("@base"in o)if(o["@base"]){const k=N(F(D,o["@base"]),g);return B.test(k)?`./${k}`:k}else return g;else return N(D,g);return g},s.compactValue=({activeCtx:o,activeProperty:g,value:f,options:L})=>{if(n(f)){const q=R(o,g,"@type"),a=R(o,g,"@language"),j=R(o,g,"@direction"),A=R(o,g,"@container")||[],k="@index"in f&&!A.includes("@index");if(!k&&q!=="@none"&&(f["@type"]===q||"@language"in f&&f["@language"]===a&&"@direction"in f&&f["@direction"]===j||"@language"in f&&f["@language"]===a||"@direction"in f&&f["@direction"]===j))return f["@value"];const p=Object.keys(f).length,G=p===1||p===2&&"@index"in f&&!k,H="@language"in o,V=b(f["@value"]),X=o.mappings.has(g)&&o.mappings.get(g)["@language"]===null;if(G&&q!=="@none"&&(!H||!V||X))return f["@value"];const S={};return k&&(S[s.compactIri({activeCtx:o,iri:"@index",relativeTo:{vocab:!0}})]=f["@index"]),"@type"in f?S[s.compactIri({activeCtx:o,iri:"@type",relativeTo:{vocab:!0}})]=s.compactIri({activeCtx:o,iri:f["@type"],relativeTo:{vocab:!0}}):"@language"in f&&(S[s.compactIri({activeCtx:o,iri:"@language",relativeTo:{vocab:!0}})]=f["@language"]),"@direction"in f&&(S[s.compactIri({activeCtx:o,iri:"@direction",relativeTo:{vocab:!0}})]=f["@direction"]),S[s.compactIri({activeCtx:o,iri:"@value",relativeTo:{vocab:!0}})]=f["@value"],S}const M=I(o,g,{vocab:!0},L),D=R(o,g,"@type"),h=s.compactIri({activeCtx:o,iri:f["@id"],relativeTo:{vocab:D==="@vocab"},base:L.base});return D==="@id"||D==="@vocab"||M==="@graph"?h:{[s.compactIri({activeCtx:o,iri:"@id",relativeTo:{vocab:!0}})]:h}};function d(o,g,f,L,M,D){D===null&&(D="@null");const h=[];if((D==="@id"||D==="@reverse")&&y(f)&&"@id"in f){D==="@reverse"&&h.push("@reverse");const a=s.compactIri({activeCtx:o,iri:f["@id"],relativeTo:{vocab:!0}});o.mappings.has(a)&&o.mappings.get(a)&&o.mappings.get(a)["@id"]===f["@id"]?h.push.apply(h,["@vocab","@id"]):h.push.apply(h,["@id","@vocab"])}else{h.push(D);const a=h.find(j=>j.includes("_"));a&&h.push(a.replace(/^[^_]+_/,"_"))}h.push("@none");const q=o.inverse[g];for(const a of L){if(!(a in q))continue;const j=q[a][M];for(const A of h)if(A in j)return j[A]}return null}function T(o,g,f){if(I(o,g,{vocab:!0},f)!=="@nest")throw new v("JSON-LD compact error; nested property must have an @nest value resolving to @nest.","jsonld.SyntaxError",{code:"invalid @nest value"})}return ze}var Xe,qt;function hn(){return qt||(qt=1,Xe=v=>{class r{toString(){return"[object JsonLdProcessor]"}}return Object.defineProperty(r,"prototype",{writable:!1,enumerable:!1}),Object.defineProperty(r.prototype,"constructor",{writable:!0,enumerable:!1,configurable:!0,value:r}),r.compact=function(y,b){return arguments.length<2?Promise.reject(new TypeError("Could not compact, too few arguments.")):v.compact(y,b)},r.expand=function(y){return arguments.length<1?Promise.reject(new TypeError("Could not expand, too few arguments.")):v.expand(y)},r.flatten=function(y){return arguments.length<1?Promise.reject(new TypeError("Could not flatten, too few arguments.")):v.flatten(y)},r}),Xe}var Qe,Jt;function pn(){if(Jt)return Qe;Jt=1;const v=Ye(),r=Zt(),y=te(),b=rn(),O=y.IdentifierIssuer,i=ne(),n=Gt(),t=sn(),{expand:c}=an(),{flatten:w}=on(),{fromRDF:I}=ln(),{toRDF:R}=un(),{frameMergedOrDefault:u,cleanupNull:m}=dn(),{isArray:E,isObject:N,isString:F}=ee(),{isSubjectReference:B}=re(),{expandIri:J,getInitialContext:l,process:e,processingMode:s}=se(),{compact:d,compactIri:T}=fn(),{createNodeMap:o,createMergedNodeMap:g,mergeNodeMaps:f}=ue(),{logEventHandler:L,logWarningEventHandler:M,safeEventHandler:D,setDefaultEventHandler:h,setupEventHandler:q,strictEventHandler:a,unhandledEventHandler:j}=oe(),A=function(p){const G={},V=new n({max:100});p.compact=async function(S,x,_){if(arguments.length<2)throw new TypeError("Could not compact, too few arguments.");if(x===null)throw new i("The compaction context must not be null.","jsonld.CompactError",{code:"invalid local context"});if(S===null)return null;_=X(_,{base:F(S)?S:"",compactArrays:!0,compactToRelative:!0,graph:!1,skipExpansion:!1,link:!1,issuer:new O("_:b"),contextResolver:new b({sharedCache:V})}),_.link&&(_.skipExpansion=!0),_.compactToRelative||delete _.base;let U;_.skipExpansion?U=S:U=await p.expand(S,_);const z=await p.processContext(l(_),x,_);let P=await d({activeCtx:z,element:U,options:_});_.compactArrays&&!_.graph&&E(P)?P.length===1?P=P[0]:P.length===0&&(P={}):_.graph&&N(P)&&(P=[P]),N(x)&&"@context"in x&&(x=x["@context"]),x=y.clone(x),E(x)||(x=[x]);const Q=x;x=[];for(let $=0;$<Q.length;++$)(!N(Q[$])||Object.keys(Q[$]).length>0)&&x.push(Q[$]);const W=x.length>0;if(x.length===1&&(x=x[0]),E(P)){const $=T({activeCtx:z,iri:"@graph",relativeTo:{vocab:!0}}),C=P;P={},W&&(P["@context"]=x),P[$]=C}else if(N(P)&&W){const $=P;P={"@context":x};for(const C in $)P[C]=$[C]}return P},p.expand=async function(S,x){if(arguments.length<1)throw new TypeError("Could not expand, too few arguments.");x=X(x,{keepFreeFloatingNodes:!1,contextResolver:new b({sharedCache:V})});const _={},U=[];if("expandContext"in x){const W=y.clone(x.expandContext);N(W)&&"@context"in W?_.expandContext=W:_.expandContext={"@context":W},U.push(_.expandContext)}let z;if(!F(S))_.input=y.clone(S);else{const W=await p.get(S,x);z=W.documentUrl,_.input=W.document,W.contextUrl&&(_.remoteContext={"@context":W.contextUrl},U.push(_.remoteContext))}"base"in x||(x.base=z||"");let P=l(x);for(const W of U)P=await e({activeCtx:P,localCtx:W,options:x});let Q=await c({activeCtx:P,element:_.input,options:x});return N(Q)&&"@graph"in Q&&Object.keys(Q).length===1?Q=Q["@graph"]:Q===null&&(Q=[]),E(Q)||(Q=[Q]),Q},p.flatten=async function(S,x,_){if(arguments.length<1)return new TypeError("Could not flatten, too few arguments.");typeof x=="function"?x=null:x=x||null,_=X(_,{base:F(S)?S:"",contextResolver:new b({sharedCache:V})});const U=await p.expand(S,_),z=w(U);return x===null?z:(_.graph=!0,_.skipExpansion=!0,await p.compact(z,x,_))},p.frame=async function(S,x,_){if(arguments.length<2)throw new TypeError("Could not frame, too few arguments.");if(_=X(_,{base:F(S)?S:"",embed:"@once",explicit:!1,requireAll:!1,omitDefault:!1,bnodesToClear:[],contextResolver:new b({sharedCache:V})}),F(x)){const K=await p.get(x,_);if(x=K.document,K.contextUrl){let Z=x["@context"];Z?E(Z)?Z.push(K.contextUrl):Z=[Z,K.contextUrl]:Z=K.contextUrl,x["@context"]=Z}}const U=x?x["@context"]||{}:{},z=await p.processContext(l(_),U,_);_.hasOwnProperty("omitGraph")||(_.omitGraph=s(z,1.1)),_.hasOwnProperty("pruneBlankNodeIdentifiers")||(_.pruneBlankNodeIdentifiers=s(z,1.1));const P=await p.expand(S,_),Q={..._};Q.isFrame=!0,Q.keepFreeFloatingNodes=!0;const W=await p.expand(x,Q),$=Object.keys(x).map(K=>J(z,K,{vocab:!0}));Q.merged=!$.includes("@graph"),Q.is11=s(z,1.1);const C=u(P,W,Q);Q.graph=!_.omitGraph,Q.skipExpansion=!0,Q.link={},Q.framing=!0;let Y=await p.compact(C,U,Q);return Q.link={},Y=m(Y,Q),Y},p.link=async function(S,x,_){const U={};return x&&(U["@context"]=x),U["@embed"]="@link",p.frame(S,U,_)},p.normalize=p.canonize=async function(S,x){if(arguments.length<1)throw new TypeError("Could not canonize, too few arguments.");x=X(x,{skipExpansion:!1,safe:!0,contextResolver:new b({sharedCache:V})});const _=Object.assign({},{algorithm:"RDFC-1.0"},x.canonizeOptions||null);if("inputFormat"in x){if(x.inputFormat!=="application/n-quads")throw new i("Unknown canonicalization input format.","jsonld.CanonizeError");const P=t.parse(S);return v.canonize(P,_)}const U={...x};delete U.format,delete U.canonizeOptions,U.produceGeneralizedRdf=!1;const z=await p.toRDF(S,U);return v.canonize(z,_)},p.fromRDF=async function(S,x){if(arguments.length<1)throw new TypeError("Could not convert from RDF, too few arguments.");x=X(x,{format:F(S)?"application/n-quads":void 0});const{format:_}=x;let{rdfParser:U}=x;if(_){if(U=U||G[_],!U)throw new i("Unknown input format.","jsonld.UnknownFormat",{format:_})}else U=()=>S;const z=await U(S);return I(z,x)},p.toRDF=async function(S,x){if(arguments.length<1)throw new TypeError("Could not convert to RDF, too few arguments.");x=X(x,{skipExpansion:!1,contextResolver:new b({sharedCache:V})});let _;x.skipExpansion?_=S:_=await p.expand(S,x);const U=R(_,x);if(x.format){if(x.format==="application/n-quads")return t.serialize(U);throw new i("Unknown output format.","jsonld.UnknownFormat",{format:x.format})}return U},p.createNodeMap=async function(S,x){if(arguments.length<1)throw new TypeError("Could not create node map, too few arguments.");x=X(x,{base:F(S)?S:"",contextResolver:new b({sharedCache:V})});const _=await p.expand(S,x);return g(_,x)},p.merge=async function(S,x,_){if(arguments.length<1)throw new TypeError("Could not merge, too few arguments.");if(!E(S))throw new TypeError('Could not merge, "docs" must be an array.');typeof x=="function"?x=null:x=x||null,_=X(_,{contextResolver:new b({sharedCache:V})});const U=await Promise.all(S.map(K=>{const Z={..._};return p.expand(K,Z)}));let z=!0;"mergeNodes"in _&&(z=_.mergeNodes);const P=_.issuer||new O("_:b"),Q={"@default":{}};for(let K=0;K<U.length;++K){const Z=y.relabelBlankNodes(U[K],{issuer:new O("_:b"+K+"-")}),le=z||K===0?Q:{"@default":{}};if(o(Z,le,"@default",P),le!==Q)for(const ce in le){const de=le[ce];if(!(ce in Q)){Q[ce]=de;continue}const et=Q[ce];for(const fe in de)fe in et||(et[fe]=de[fe])}}const W=f(Q),$=[],C=Object.keys(W).sort();for(let K=0;K<C.length;++K){const Z=W[C[K]];B(Z)||$.push(Z)}return x===null?$:(_.graph=!0,_.skipExpansion=!0,await p.compact($,x,_))},Object.defineProperty(p,"documentLoader",{get:()=>p._documentLoader,set:S=>p._documentLoader=S}),p.documentLoader=async S=>{throw new i("Could not retrieve a JSON-LD document from the URL. URL dereferencing not implemented.","jsonld.LoadDocumentError",{code:"loading document failed",url:S})},p.get=async function(S,x){let _;typeof x.documentLoader=="function"?_=x.documentLoader:_=p.documentLoader;const U=await _(S);try{if(!U.document)throw new i("No remote document found at the given URL.","jsonld.NullRemoteDocument");F(U.document)&&(U.document=JSON.parse(U.document))}catch(z){throw new i("Could not retrieve a JSON-LD document from the URL.","jsonld.LoadDocumentError",{code:"loading document failed",cause:z,remoteDoc:U})}return U},p.processContext=async function(S,x,_){return _=X(_,{base:"",contextResolver:new b({sharedCache:V})}),x===null?l(_):(x=y.clone(x),N(x)&&"@context"in x||(x={"@context":x}),e({activeCtx:S,localCtx:x,options:_}))},p.getContextValue=se().getContextValue,p.documentLoaders={},p.useDocumentLoader=function(S){if(!(S in p.documentLoaders))throw new i('Unknown document loader type: "'+S+'"',"jsonld.UnknownDocumentLoader",{type:S});p.documentLoader=p.documentLoaders[S].apply(p,Array.prototype.slice.call(arguments,1))},p.registerRDFParser=function(S,x){G[S]=x},p.unregisterRDFParser=function(S){delete G[S]},p.registerRDFParser("application/n-quads",t.parse),p.url=ie(),p.logEventHandler=L,p.logWarningEventHandler=M,p.safeEventHandler=D,p.setDefaultEventHandler=h,p.strictEventHandler=a,p.unhandledEventHandler=j,p.util=y,Object.assign(p,y),p.promises=p,p.RequestQueue=Vt(),p.JsonLdProcessor=hn()(p),r.setupGlobals(p),r.setupDocumentLoaders(p);function X(S,{documentLoader:x=p.documentLoader,..._}){if(S&&"compactionMap"in S)throw new i('"compactionMap" not supported.',"jsonld.OptionsError");if(S&&"expansionMap"in S)throw new i('"expansionMap" not supported.',"jsonld.OptionsError");return Object.assign({},{documentLoader:x},_,S,{eventHandler:q({options:S})})}return p},k=function(){return A(function(){return k()})};return A(k),Qe=k,Qe}var $t=pn();const gn=zt($t),Sn=Xt({__proto__:null,default:gn},[$t]);export{Sn as j};
